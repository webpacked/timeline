# Architecture

Timeline is built as a layered system, with each layer having clear responsibilities and boundaries.

## System Layers

```
┌─────────────────────────────────────┐
│           CLI / Registry            │  Future: Component installation
├─────────────────────────────────────┤
│          UI Components              │  Future: Installable components
├─────────────────────────────────────┤
│         React Adapter               │  Hooks, Context, Subscriptions
├─────────────────────────────────────┤
│          Core Engine                │  State, Validation, History
└─────────────────────────────────────┘
```

### Core Engine (`@timeline/core`)

**Responsibilities:**

- Timeline state management
- Frame-based time system
- Validation rules
- History (undo/redo)
- Built-in systems (snapping, grouping, linking)

**Key Characteristics:**

- Framework-agnostic
- Pure TypeScript
- No DOM dependencies
- Deterministic
- Fully tested

**Public API:**

- `TimelineEngine` - Main engine class
- Factory functions (`createTimeline`, `createTrack`, `createClip`, etc.)
- Type definitions
- Utility functions (`frame`, `frameRate`, etc.)

### React Adapter (`@timeline/react`)

**Responsibilities:**

- React integration
- Subscription management
- Hook-based API
- Context provider

**Key Characteristics:**

- Thin adapter layer
- No business logic
- No state duplication
- Automatic cleanup

**Public API:**

- `TimelineProvider` - Context provider
- `useTimeline()` - Full state hook
- `useTrack(id)` - Track-specific hook
- `useClip(id)` - Clip-specific hook
- `useEngine()` - Engine access hook

### UI Components (Future)

**Planned:**

- Installable via CLI
- Customizable
- Composable
- Framework-specific implementations

### CLI / Registry (Future)

**Planned:**

- Component installation
- Registry hosting
- Version management
- Source code serving

## Core Concepts

### Frame-Based Time

Timeline uses frame numbers instead of milliseconds for several reasons:

**Deterministic:**

```typescript
// Always exact, no floating point errors
const start = frame(0);
const end = frame(100);
const duration = end - start; // Always 100
```

**Video-Native:**

```typescript
// Aligns with video frame boundaries
const fps = frameRate(30);
const oneSecond = frame(30); // Exactly 1 second @ 30fps
```

**Reproducible:**

```typescript
// Same operations always produce same result
const clip1 = createClip({ timelineStart: frame(0), timelineEnd: frame(100) });
const clip2 = createClip({ timelineStart: frame(0), timelineEnd: frame(100) });
// clip1 and clip2 are identical
```

### Deterministic State

Every operation is deterministic:

```typescript
// Given the same initial state and operations
const engine1 = new TimelineEngine(initialState);
engine1.addTrack(track);
engine1.addClip(trackId, clip);

const engine2 = new TimelineEngine(initialState);
engine2.addTrack(track);
engine2.addClip(trackId, clip);

// engine1 and engine2 have identical state
```

This enables:

- Reliable testing
- Reproducible bugs
- State serialization
- Collaborative editing (future)

### Subscription Model

The engine uses a simple pub/sub pattern:

```typescript
class TimelineEngine {
  private listeners = new Set<() => void>();

  subscribe(listener: () => void): () => void {
    this.listeners.add(listener);
    return () => this.listeners.delete(listener);
  }

  private notify(): void {
    this.listeners.forEach((listener) => listener());
  }
}
```

**Benefits:**

- Simple to understand
- Easy to implement
- Efficient for most use cases
- Framework-agnostic

**React Integration:**

```typescript
function useTimeline() {
  const engine = useEngine();
  const [state, setState] = useState(() => engine.getState());

  useEffect(() => {
    const unsubscribe = engine.subscribe(() => {
      setState(engine.getState());
    });
    return unsubscribe;
  }, [engine]);

  return { state, engine };
}
```

### Validation System

Built-in validation ensures state integrity:

```typescript
// Clips cannot overlap on the same track
engine.addClip(trackId, {
  timelineStart: frame(0),
  timelineEnd: frame(100),
}); // ✓ OK

engine.addClip(trackId, {
  timelineStart: frame(50),
  timelineEnd: frame(150),
}); // ✗ Error: Overlaps with existing clip
```

**Validation Rules:**

- No overlapping clips on same track
- Clip duration must match media duration
- Timeline start must be before end
- Track IDs must be unique
- Asset must exist before creating clip

### History System

Automatic undo/redo for all operations:

```typescript
// Operations are automatically tracked
engine.addTrack(track);
engine.addClip(trackId, clip);
engine.moveClip(clipId, frame(100));

// Undo last operation
engine.undo(); // Clip moved back

// Undo again
engine.undo(); // Clip removed

// Undo again
engine.undo(); // Track removed

// Redo
engine.redo(); // Track added back
```

**Implementation:**

- Command pattern
- Immutable snapshots
- Configurable history limit
- Memory efficient

## Built-in Systems

### Snapping System

Automatically snap clips to nearby boundaries:

```typescript
const snappingSystem = new SnappingSystem({
  enabled: true,
  threshold: frame(5), // Snap within 5 frames
});

// When moving a clip, it snaps to:
// - Track boundaries
// - Other clip edges
// - Playhead position
```

### Grouping System

Group clips together for batch operations:

```typescript
const groupingSystem = new GroupingSystem();

// Create a group
const groupId = groupingSystem.createGroup([clip1.id, clip2.id]);

// Move all clips in group
groupingSystem.moveGroup(groupId, frame(100));
```

### Linking System

Link clips across tracks:

```typescript
const linkingSystem = new LinkingSystem();

// Link audio and video clips
linkingSystem.link(videoClipId, audioClipId);

// Moving one moves both
engine.moveClip(videoClipId, frame(100));
// audioClip also moved to frame(100)
```

## Design Principles

### 1. Framework Agnostic Core

The core engine has zero framework dependencies:

```typescript
// Works anywhere JavaScript runs
import { TimelineEngine } from "@timeline/core";

// Node.js
const engine = new TimelineEngine(state);

// Browser
const engine = new TimelineEngine(state);

// React
const engine = new TimelineEngine(state);

// Vue, Angular, Svelte, etc.
const engine = new TimelineEngine(state);
```

### 2. Thin Adapter Layers

Adapters contain no business logic:

```typescript
// ✓ Good: Adapter just subscribes and re-renders
function useTimeline() {
  const engine = useEngine();
  const [state, setState] = useState(() => engine.getState());

  useEffect(() => {
    return engine.subscribe(() => setState(engine.getState()));
  }, [engine]);

  return { state, engine };
}

// ✗ Bad: Adapter contains business logic
function useTimeline() {
  const engine = useEngine();
  const [state, setState] = useState(() => engine.getState());

  const addTrack = (name: string) => {
    // Business logic in adapter - wrong layer!
    const track = createTrack({ id: generateId(), name, type: "video" });
    engine.addTrack(track);
  };

  return { state, addTrack };
}
```

### 3. Single Source of Truth

Engine state is the only source of truth:

```typescript
// ✓ Good: No state duplication
function TimelineView() {
  const { state } = useTimeline();
  return <div>{state.timeline.tracks.length} tracks</div>;
}

// ✗ Bad: Duplicating state in React
function TimelineView() {
  const { state } = useTimeline();
  const [trackCount, setTrackCount] = useState(0);

  useEffect(() => {
    setTrackCount(state.timeline.tracks.length);
  }, [state]);

  return <div>{trackCount} tracks</div>;
}
```

### 4. Explicit Over Implicit

Operations are explicit and clear:

```typescript
// ✓ Good: Explicit frame numbers
engine.moveClip(clipId, frame(100));

// ✗ Bad: Implicit time units
engine.moveClip(clipId, 100); // 100 what? Frames? Milliseconds?
```

### 5. Immutable State

State is never mutated directly:

```typescript
// ✓ Good: Engine creates new state
const newState = engine.addTrack(track);

// ✗ Bad: Mutating state directly
state.timeline.tracks.push(track); // Don't do this!
```

## Future Architecture

### Registry System

The registry will serve component source code:

```
GET /registry/timeline-view.json
{
  "name": "timeline-view",
  "version": "1.0.0",
  "files": [
    {
      "path": "timeline-view.tsx",
      "content": "..."
    }
  ],
  "dependencies": ["@timeline/react"]
}
```

### CLI Integration

Install components directly:

```bash
npx timeline add timeline-view
```

This will:

1. Fetch component from registry
2. Copy source to your project
3. Install dependencies
4. Update imports

### Playground

Embedded demo with live editing:

```typescript
// Edit code in browser
// See changes in real-time
// Share via URL
```

## Performance Considerations

### Current Approach

The current subscription model is simple and sufficient for most use cases:

```typescript
// All subscribers notified on any change
engine.subscribe(() => {
  // Re-render everything
});
```

### Future Optimizations

If profiling shows performance issues, consider:

**Selector-based subscriptions:**

```typescript
const track = useSelector((state) => state.timeline.tracks[0]);
```

**Memoized selectors:**

```typescript
const trackCount = useMemo(
  () => state.timeline.tracks.length,
  [state.timeline.tracks],
);
```

**Virtual scrolling:**

```typescript
// Only render visible clips
<VirtualList items={clips} />
```

**Canvas rendering:**

```typescript
// Render timeline on canvas for performance
<CanvasTimeline />
```

**Current principle:** Optimize only when profiling shows actual issues.
