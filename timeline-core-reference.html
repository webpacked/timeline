<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Timeline Library Master Blueprint ‚Äî From Zero to Production</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@300;400;500;600&display=swap');

*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --bg: #0a0a0a;
  --bg2: #111111;
  --bg3: #1a1a1a;
  --bg4: #0d0d0d;
  --text: #ededed;
  --text2: #a1a1a1;
  --text3: #737373;
  --text4: #525252;
  --border: #262626;
  --border2: #404040;
  --accent: #3b82f6;
  --accent-dim: #1e40af;
  --accent-glow: rgba(59, 130, 246, 0.15);
  --green: #22c55e;
  --green-dim: #16a34a;
  --amber: #f59e0b;
  --amber-dim: #d97706;
  --red: #ef4444;
  --red-dim: #dc2626;
  --purple: #a855f7;
  --purple-dim: #9333ea;
  --cyan: #06b6d4;
  --cyan-dim: #0891b2;
  --code-bg: #0d0d0d;
  --mono: 'JetBrains Mono', monospace;
  --sans: 'Inter', sans-serif;
}

html { scroll-behavior: smooth; }

body {
  background: var(--bg);
  color: var(--text);
  font-family: var(--sans);
  font-size: 14px;
  line-height: 1.7;
  -webkit-font-smoothing: antialiased;
}

/* ‚ïê‚ïê‚ïê LAYOUT ‚ïê‚ïê‚ïê */
.layout {
  display: grid;
  grid-template-columns: 300px 1fr;
  min-height: 100vh;
}

/* ‚ïê‚ïê‚ïê SIDEBAR ‚ïê‚ïê‚ïê */
.sidebar {
  background: var(--bg2);
  border-right: 1px solid var(--border);
  position: sticky;
  top: 0;
  height: 100vh;
  overflow-y: auto;
  padding: 32px 0;
  scrollbar-width: thin;
  scrollbar-color: var(--border2) transparent;
}

.sidebar-logo {
  padding: 0 24px 24px;
  border-bottom: 1px solid var(--border);
  margin-bottom: 20px;
}
.sidebar-logo .logo-label {
  font-size: 10px;
  letter-spacing: 0.15em;
  text-transform: uppercase;
  color: var(--text3);
  margin-bottom: 8px;
  font-weight: 500;
}
.sidebar-logo h1 {
  font-size: 22px;
  font-weight: 800;
  color: var(--text);
  line-height: 1.3;
  letter-spacing: -0.03em;
  background: linear-gradient(135deg, var(--accent) 0%, var(--purple) 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.nav-section { margin-bottom: 24px; }
.nav-label {
  font-size: 10px;
  letter-spacing: 0.15em;
  text-transform: uppercase;
  color: var(--text3);
  padding: 0 24px 8px;
  font-weight: 600;
}
.nav-item {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 8px 24px;
  color: var(--text2);
  text-decoration: none;
  font-size: 13px;
  transition: all 0.15s;
  border-left: 2px solid transparent;
  cursor: pointer;
}
.nav-item:hover { 
  color: var(--text); 
  background: rgba(255,255,255,0.03); 
  border-left-color: var(--accent);
}
.nav-item.active { 
  color: var(--text); 
  background: var(--accent-glow);
  border-left-color: var(--accent);
  font-weight: 500;
}
.nav-icon {
  width: 18px;
  height: 18px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
}

/* ‚ïê‚ïê‚ïê CONTENT ‚ïê‚ïê‚ïê */
.content {
  padding: 64px 80px 120px;
  max-width: 1100px;
}

/* ‚ïê‚ïê‚ïê HERO ‚ïê‚ïê‚ïê */
.hero {
  margin-bottom: 96px;
  padding: 64px 0;
  border-bottom: 1px solid var(--border);
}
.hero-tag {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  font-size: 11px;
  letter-spacing: 0.12em;
  text-transform: uppercase;
  color: var(--accent);
  margin-bottom: 20px;
  font-weight: 600;
  padding: 6px 12px;
  background: var(--accent-glow);
  border-radius: 6px;
  border: 1px solid rgba(59, 130, 246, 0.3);
}
.hero-tag::before {
  content: '‚ö°';
  font-size: 14px;
}
.hero h1 {
  font-size: 56px;
  font-weight: 800;
  color: var(--text);
  line-height: 1.1;
  margin-bottom: 24px;
  letter-spacing: -0.04em;
}
.hero-subtitle {
  font-size: 20px;
  color: var(--text2);
  line-height: 1.6;
  max-width: 800px;
  margin-bottom: 32px;
}
.hero-stats {
  display: flex;
  gap: 40px;
  margin-top: 40px;
}
.stat {
  display: flex;
  flex-direction: column;
  gap: 4px;
}
.stat-value {
  font-size: 32px;
  font-weight: 700;
  color: var(--accent);
  line-height: 1;
}
.stat-label {
  font-size: 12px;
  color: var(--text3);
  text-transform: uppercase;
  letter-spacing: 0.1em;
}

/* ‚ïê‚ïê‚ïê SECTION ‚ïê‚ïê‚ïê */
.section {
  margin-bottom: 96px;
  animation: fadeup 0.5s ease both;
}
@keyframes fadeup {
  from { opacity: 0; transform: translateY(12px); }
  to { opacity: 1; transform: translateY(0); }
}

.section-tag {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  font-size: 11px;
  letter-spacing: 0.12em;
  text-transform: uppercase;
  color: var(--accent);
  margin-bottom: 12px;
  font-weight: 600;
}
.section-tag::before {
  content: '';
  width: 3px;
  height: 3px;
  border-radius: 50%;
  background: var(--accent);
}

h2 {
  font-size: 40px;
  font-weight: 700;
  color: var(--text);
  line-height: 1.2;
  margin-bottom: 16px;
  letter-spacing: -0.03em;
}
.section-intro {
  color: var(--text2);
  font-size: 17px;
  line-height: 1.7;
  margin-bottom: 40px;
  max-width: 800px;
}
h3 {
  font-size: 28px;
  font-weight: 600;
  color: var(--text);
  margin: 48px 0 16px;
  letter-spacing: -0.02em;
}
h4 {
  font-size: 18px;
  font-weight: 600;
  color: var(--text);
  margin: 32px 0 12px;
}
h5 {
  font-size: 15px;
  font-weight: 600;
  color: var(--text);
  margin: 24px 0 8px;
}
p {
  color: var(--text2);
  margin-bottom: 16px;
  font-size: 15px;
  line-height: 1.7;
}

ul, ol {
  margin: 16px 0;
  padding-left: 24px;
  color: var(--text2);
}
li {
  margin-bottom: 8px;
  line-height: 1.7;
}

strong {
  color: var(--text);
  font-weight: 600;
}

code {
  font-family: var(--mono);
  font-size: 13px;
  background: var(--code-bg);
  padding: 3px 7px;
  border-radius: 4px;
  color: var(--accent);
  border: 1px solid var(--border);
}

/* ‚ïê‚ïê‚ïê CODE BLOCKS ‚ïê‚ïê‚ïê */
.code-block {
  background: var(--bg3);
  border: 1px solid var(--border);
  border-radius: 10px;
  overflow: hidden;
  margin: 24px 0;
  box-shadow: 0 4px 6px rgba(0,0,0,0.3);
}
.code-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px 20px;
  border-bottom: 1px solid var(--border);
  background: var(--bg2);
}
.code-filename {
  font-family: var(--mono);
  font-size: 12px;
  color: var(--text);
  font-weight: 500;
}
.code-lang {
  font-size: 10px;
  text-transform: uppercase;
  letter-spacing: 0.1em;
  color: var(--text3);
  background: var(--bg3);
  padding: 4px 10px;
  border-radius: 4px;
}
pre {
  padding: 24px;
  overflow-x: auto;
  font-family: var(--mono);
  font-size: 13px;
  line-height: 1.8;
  color: var(--text);
}

/* ‚ïê‚ïê‚ïê SYNTAX HIGHLIGHTING ‚ïê‚ïê‚ïê */
.k { color: #c678dd; } /* keyword */
.t { color: #e5c07b; } /* type */
.s { color: #98c379; } /* string */
.n { color: #e06c75; } /* number */
.v { color: #61afef; } /* variable */
.f { color: #61afef; } /* function */
.c { color: #5c6370; font-style: italic; } /* comment */
.o { color: #56b6c2; } /* operator */
.p { color: #abb2bf; } /* punctuation */

/* ‚ïê‚ïê‚ïê CALLOUTS ‚ïê‚ïê‚ïê */
.callout {
  background: var(--bg3);
  border-left: 3px solid var(--accent);
  border-radius: 8px;
  padding: 20px 24px;
  margin: 24px 0;
}
.callout-title {
  font-weight: 600;
  color: var(--text);
  margin-bottom: 12px;
  font-size: 15px;
  display: flex;
  align-items: center;
  gap: 8px;
}
.callout p {
  margin-bottom: 8px;
  font-size: 14px;
}
.callout p:last-child { margin-bottom: 0; }
.callout-warning {
  border-left-color: var(--amber);
  background: rgba(245, 158, 11, 0.05);
}
.callout-warning .callout-title { color: var(--amber); }
.callout-danger {
  border-left-color: var(--red);
  background: rgba(239, 68, 68, 0.05);
}
.callout-danger .callout-title { color: var(--red); }
.callout-success {
  border-left-color: var(--green);
  background: rgba(34, 197, 94, 0.05);
}
.callout-success .callout-title { color: var(--green); }
.callout-info {
  border-left-color: var(--cyan);
  background: rgba(6, 182, 212, 0.05);
}
.callout-info .callout-title { color: var(--cyan); }

/* ‚ïê‚ïê‚ïê COMPARISON TABLE ‚ïê‚ïê‚ïê */
.comparison {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
  gap: 20px;
  margin: 32px 0;
}
.comparison-card {
  background: var(--bg3);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 24px;
  transition: all 0.2s;
}
.comparison-card:hover {
  border-color: var(--border2);
  transform: translateY(-2px);
}
.comparison-card h4 {
  margin: 0 0 12px 0;
  color: var(--text);
  font-size: 16px;
}
.comparison-card p {
  font-size: 13px;
  margin: 0;
  line-height: 1.6;
}
.comparison-card.highlight {
  border-color: var(--accent);
  background: var(--accent-glow);
}

/* ‚ïê‚ïê‚ïê FEATURE GRID ‚ïê‚ïê‚ïê */
.feature-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 24px;
  margin: 32px 0;
}
.feature-card {
  background: var(--bg3);
  border: 1px solid var(--border);
  border-radius: 10px;
  padding: 28px;
  transition: all 0.2s;
}
.feature-card:hover {
  border-color: var(--accent);
  transform: translateY(-4px);
  box-shadow: 0 8px 16px rgba(0,0,0,0.3);
}
.feature-icon {
  font-size: 32px;
  margin-bottom: 16px;
  display: block;
}
.feature-card h4 {
  margin: 0 0 12px 0;
  font-size: 17px;
}
.feature-card p {
  font-size: 14px;
  margin: 0;
  color: var(--text3);
}

/* ‚ïê‚ïê‚ïê ARCHITECTURE DIAGRAM ‚ïê‚ïê‚ïê */
.arch-diagram {
  background: var(--bg2);
  border: 1px solid var(--border);
  border-radius: 10px;
  padding: 40px;
  margin: 32px 0;
}
.arch-layer {
  background: var(--bg3);
  border: 1px solid var(--border2);
  border-radius: 8px;
  padding: 20px;
  margin-bottom: 16px;
}
.arch-layer:last-child { margin-bottom: 0; }
.arch-layer-title {
  font-weight: 600;
  color: var(--accent);
  font-size: 14px;
  margin-bottom: 12px;
  text-transform: uppercase;
  letter-spacing: 0.1em;
}
.arch-layer-content {
  color: var(--text2);
  font-size: 14px;
  line-height: 1.6;
}

/* ‚ïê‚ïê‚ïê DECISION MATRIX ‚ïê‚ïê‚ïê */
.decision-table {
  background: var(--bg3);
  border: 1px solid var(--border);
  border-radius: 8px;
  overflow: hidden;
  margin: 24px 0;
}
.decision-table table {
  width: 100%;
  border-collapse: collapse;
}
.decision-table th {
  background: var(--bg2);
  padding: 12px 16px;
  text-align: left;
  font-size: 13px;
  font-weight: 600;
  color: var(--text);
  border-bottom: 1px solid var(--border);
}
.decision-table td {
  padding: 12px 16px;
  font-size: 13px;
  color: var(--text2);
  border-bottom: 1px solid var(--border);
}
.decision-table tr:last-child td {
  border-bottom: none;
}
.decision-table .good { color: var(--green); }
.decision-table .bad { color: var(--red); }
.decision-table .neutral { color: var(--amber); }

/* ‚ïê‚ïê‚ïê TIMELINE PHASES ‚ïê‚ïê‚ïê */
.phase {
  background: var(--bg3);
  border: 1px solid var(--border);
  border-left: 3px solid var(--accent);
  border-radius: 8px;
  padding: 24px;
  margin-bottom: 20px;
  transition: all 0.2s;
}
.phase:hover {
  border-left-width: 5px;
  transform: translateX(4px);
}
.phase-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
}
.phase-title {
  font-size: 18px;
  font-weight: 600;
  color: var(--text);
}
.phase-timeline {
  font-size: 12px;
  color: var(--text3);
  background: var(--bg2);
  padding: 4px 12px;
  border-radius: 12px;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}
.phase-desc {
  color: var(--text2);
  margin-bottom: 16px;
  font-size: 14px;
}
.phase-tasks {
  list-style: none;
  padding: 0;
}
.phase-tasks li {
  padding: 8px 0 8px 28px;
  position: relative;
  font-size: 14px;
  color: var(--text3);
}
.phase-tasks li::before {
  content: '‚Üí';
  position: absolute;
  left: 0;
  color: var(--accent);
  font-weight: bold;
}

/* ‚ïê‚ïê‚ïê CHECKLIST ‚ïê‚ïê‚ïê */
.checklist {
  background: var(--bg3);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 24px;
  margin: 24px 0;
}
.checklist-item {
  display: flex;
  align-items: start;
  gap: 12px;
  padding: 12px 0;
  border-bottom: 1px solid var(--border);
}
.checklist-item:last-child { border-bottom: none; }
.checklist-checkbox {
  width: 18px;
  height: 18px;
  border: 2px solid var(--border2);
  border-radius: 4px;
  flex-shrink: 0;
  margin-top: 2px;
}
.checklist-text {
  color: var(--text2);
  font-size: 14px;
  line-height: 1.6;
}

hr {
  border: none;
  border-top: 1px solid var(--border);
  margin: 64px 0;
}
</style>
</head>
<body>

<div class="layout">
  <nav class="sidebar">
    <div class="sidebar-logo">
      <div class="logo-label">Master Blueprint</div>
      <h1>Timeline Library</h1>
    </div>

    <div class="nav-section">
      <div class="nav-label">Foundation</div>
      <a class="nav-item" href="#introduction">
        <span class="nav-icon">üéØ</span>
        <span>Introduction</span>
      </a>
      <a class="nav-item" href="#vision">
        <span class="nav-icon">üîÆ</span>
        <span>Vision & Goals</span>
      </a>
      <a class="nav-item" href="#architecture">
        <span class="nav-icon">üèóÔ∏è</span>
        <span>Architecture</span>
      </a>
    </div>

    <div class="nav-section">
      <div class="nav-label">Core Concepts</div>
      <a class="nav-item" href="#how-timeline-works">
        <span class="nav-icon">‚öôÔ∏è</span>
        <span>How Timeline Works</span>
      </a>
      <a class="nav-item" href="#data-model">
        <span class="nav-icon">üìä</span>
        <span>Data Model</span>
      </a>
      <a class="nav-item" href="#state-management">
        <span class="nav-icon">üîÑ</span>
        <span>State Management</span>
      </a>
    </div>

    <div class="nav-section">
      <div class="nav-label">Technical Stack</div>
      <a class="nav-item" href="#monorepo">
        <span class="nav-icon">üì¶</span>
        <span>Monorepo Setup</span>
      </a>
      <a class="nav-item" href="#tech-choices">
        <span class="nav-icon">üõ†Ô∏è</span>
        <span>Technology Choices</span>
      </a>
      <a class="nav-item" href="#framework-adapters">
        <span class="nav-icon">üîå</span>
        <span>Framework Adapters</span>
      </a>
    </div>

    <div class="nav-section">
      <div class="nav-label">Implementation</div>
      <a class="nav-item" href="#core-package">
        <span class="nav-icon">üíé</span>
        <span>Core Package</span>
      </a>
      <a class="nav-item" href="#react-package">
        <span class="nav-icon">‚öõÔ∏è</span>
        <span>React Package</span>
      </a>
      <a class="nav-item" href="#components">
        <span class="nav-icon">üß©</span>
        <span>Components</span>
      </a>
      <a class="nav-item" href="#cli">
        <span class="nav-icon">üíª</span>
        <span>CLI Tool</span>
      </a>
    </div>

    <div class="nav-section">
      <div class="nav-label">Advanced</div>
      <a class="nav-item" href="#performance">
        <span class="nav-icon">‚ö°</span>
        <span>Performance</span>
      </a>
      <a class="nav-item" href="#testing">
        <span class="nav-icon">üß™</span>
        <span>Testing Strategy</span>
      </a>
      <a class="nav-item" href="#documentation">
        <span class="nav-icon">üìö</span>
        <span>Documentation</span>
      </a>
    </div>

    <div class="nav-section">
      <div class="nav-label">Execution</div>
      <a class="nav-item" href="#roadmap">
        <span class="nav-icon">üó∫Ô∏è</span>
        <span>Development Roadmap</span>
      </a>
      <a class="nav-item" href="#pitfalls">
        <span class="nav-icon">‚ö†Ô∏è</span>
        <span>Common Pitfalls</span>
      </a>
      <a class="nav-item" href="#next-steps">
        <span class="nav-icon">üöÄ</span>
        <span>Next Steps</span>
      </a>
    </div>
  </nav>

  <main class="content">
    <!-- ‚ïê‚ïê‚ïê HERO ‚ïê‚ïê‚ïê -->
    <div class="hero">
      <div class="hero-tag">Complete Implementation Guide</div>
      <h1>Build a Timeline Library<br>Like shadcn/ui</h1>
      <p class="hero-subtitle">
        A comprehensive, step-by-step blueprint for building a production-ready, framework-agnostic timeline library with CLI installation, extensible components, and video editor capabilities ‚Äî from first principles to shipped product.
      </p>
      <div class="hero-stats">
        <div class="stat">
          <div class="stat-value">4</div>
          <div class="stat-label">Core Packages</div>
        </div>
        <div class="stat">
          <div class="stat-value">12+</div>
          <div class="stat-label">Components</div>
        </div>
        <div class="stat">
          <div class="stat-value">‚àû</div>
          <div class="stat-label">Possibilities</div>
        </div>
      </div>
    </div>

    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
    <!-- INTRODUCTION -->
    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
    
    <div class="section" id="introduction">
      <div class="section-tag">Chapter 1</div>
      <h2>Introduction: What You're Building</h2>
      <p class="section-intro">
        You're not building a video editor. You're building the <strong>foundation</strong> that enables a thousand video editors, audio editors, animation tools, and timeline-based applications to exist. This is a library, not an application.
      </p>

      <h3>The Core Concept</h3>
      <p>Think of your timeline library as three distinct layers:</p>

      <div class="arch-diagram">
        <div class="arch-layer">
          <div class="arch-layer-title">Layer 1: Pure Logic (@timeline/core)</div>
          <div class="arch-layer-content">
            Framework-agnostic TypeScript functions that manipulate timeline data. No React, no Vue, no DOM. Just pure functions that take a timeline state and return a new timeline state. This is your mathematical core ‚Äî the "engine" of truth.
          </div>
        </div>

        <div class="arch-layer">
          <div class="arch-layer-title">Layer 2: Framework Adapters (@timeline/react, @timeline/vue)</div>
          <div class="arch-layer-content">
            Thin wrappers that connect the pure core to specific frameworks. In React, these are hooks. In Vue, these are composables. They handle state management, side effects, and reactivity ‚Äî but they don't contain business logic.
          </div>
        </div>

        <div class="arch-layer">
          <div class="arch-layer-title">Layer 3: UI Components (registry/components/)</div>
          <div class="arch-layer-content">
            Actual timeline UI components (Timeline, Track, Clip, Playhead, etc.) that users install via CLI. These are unstyled primitives (like Radix) that the user fully owns and customizes. They live in the user's codebase, not as dependencies.
          </div>
        </div>
      </div>

      <div class="callout callout-info">
        <div class="callout-title">üí° The shadcn Model</div>
        <p>You're following the shadcn/ui philosophy: <strong>copy, don't install</strong>. Components aren't distributed as npm packages ‚Äî they're source code files that get copied into the user's project. This gives users 100% control while you provide the starting point.</p>
      </div>

      <h3>What Makes This Different</h3>
      <p>Traditional libraries (like Timeline.js or Vis.js) are monolithic: they bundle everything together. You install one package and get opinionated UI, styling, and logic all mixed together. This makes customization painful.</p>

      <p>Your approach is modular and composable:</p>
      <ul>
        <li><strong>Core logic is separate</strong> ‚Äî Users can build their own UI on top</li>
        <li><strong>Components are owned by users</strong> ‚Äî They modify source code, not fight with props</li>
        <li><strong>Framework adapters are thin</strong> ‚Äî Easy to support React, Vue, Svelte, Solid</li>
        <li><strong>No opinions on styling</strong> ‚Äî Users bring their own CSS/Tailwind/etc.</li>
      </ul>
    </div>

    <hr>

    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
    <!-- VISION & GOALS -->
    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->

    <div class="section" id="vision">
      <div class="section-tag">Chapter 2</div>
      <h2>Vision & Goals</h2>
      <p class="section-intro">
        Let's crystalize exactly what you're building and why. This keeps you focused when you inevitably face 1000 implementation choices.
      </p>

      <h3>Primary Goal</h3>
      <p>Build a <strong>timeline component library</strong> that developers can install with a single CLI command and customize completely. The timeline should be flexible enough to power:</p>
      <ul>
        <li>Video editors (DaVinci Resolve, Premiere)</li>
        <li>Audio editors (Audacity, GarageBand)</li>
        <li>Animation tools (After Effects, Rive)</li>
        <li>Project management tools (Gantt charts)</li>
        <li>Music production (FL Studio, Ableton)</li>
      </ul>

      <h3>Secondary Goal (Future)</h3>
      <p>Eventually expand into a full <strong>video editing library</strong> by adding:</p>
      <ul>
        <li>Video/audio playback synchronization</li>
        <li>Real-time preview rendering</li>
        <li>Effects pipeline (transitions, filters, transforms)</li>
        <li>Export/encoding capabilities</li>
      </ul>

      <div class="callout callout-warning">
        <div class="callout-title">‚ö†Ô∏è Critical: Start Small</div>
        <p><strong>Do NOT build the video editor features first.</strong> Build an excellent timeline library first. Get that right. Make it successful. The video editor features can be added later as optional packages (@timeline/playback, @timeline/effects, @timeline/export).</p>
        <p>If you start building everything at once, you'll burn out and ship nothing.</p>
      </div>

      <h3>Success Metrics</h3>
      <div class="feature-grid">
        <div class="feature-card">
          <span class="feature-icon">üé®</span>
          <h4>Extreme Flexibility</h4>
          <p>Users can customize every visual aspect and behavior. No "this is how it works" ‚Äî only "here's a starting point."</p>
        </div>

        <div class="feature-card">
          <span class="feature-icon">‚ö°</span>
          <h4>Performance First</h4>
          <p>Handle 1000+ clips without lag. Virtualization, efficient re-renders, optimized calculations.</p>
        </div>

        <div class="feature-card">
          <span class="feature-icon">üì¶</span>
          <h4>Developer Experience</h4>
          <p>Install in 30 seconds. Great TypeScript support. Excellent docs. Feels like magic.</p>
        </div>

        <div class="feature-card">
          <span class="feature-icon">üîå</span>
          <h4>Framework Agnostic</h4>
          <p>Core logic works anywhere. Adapters for React, Vue, Svelte. Easy to add new frameworks.</p>
        </div>
      </div>
    </div>

    <hr>

    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
    <!-- ARCHITECTURE -->
    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->

    <div class="section" id="architecture">
      <div class="section-tag">Chapter 3</div>
      <h2>Architecture Deep Dive</h2>
      <p class="section-intro">
        This is the most important section. Get the architecture right and everything else flows naturally. Get it wrong and you'll rewrite everything later.
      </p>

      <h3>The Three-Layer Architecture (Current Implementation)</h3>
      <p>The timeline library is built on three distinct layers with clear separation of concerns:</p>

      <h4>1. Core Layer (@timeline/core) - The Engine</h4>
      <p>The core is a <strong>deterministic, frame-based timeline editing kernel</strong> with:</p>
      <ul>
        <li><strong>TimelineEngine</strong> ‚Äî Main API with 41 public methods for all operations</li>
        <li><strong>8 Internal Systems</strong> ‚Äî Validation, queries, snapping, linking, grouping, clipboard, drag-state, asset-registry</li>
        <li><strong>Immutable state</strong> ‚Äî All operations return new state, never mutate</li>
        <li><strong>Built-in undo/redo</strong> ‚Äî History system with configurable limits</li>
        <li><strong>Frame-based time</strong> ‚Äî Deterministic, no floating-point errors</li>
        <li><strong>Zero framework dependencies</strong> ‚Äî Pure TypeScript</li>
      </ul>

      <div class="code-block">
        <div class="code-header">
          <span class="code-filename">packages/core/src/engine/timeline-engine.ts</span>
          <span class="code-lang">typescript</span>
        </div>
        <pre><span class="c">// The TimelineEngine is the main public API</span>
<span class="k">import</span> { TimelineEngine, createTimelineState } <span class="k">from</span> <span class="s">'@timeline/core'</span>

<span class="c">// Create engine with initial state</span>
<span class="k">const</span> <span class="v">engine</span> = <span class="k">new</span> TimelineEngine(createTimelineState({
  timeline: createTimeline({ <span class="c">/* ... */</span> })
}))

<span class="c">// All operations go through the engine</span>
engine.addTrack(track)           <span class="c">// Returns DispatchResult</span>
engine.addClip(trackId, clip)    <span class="c">// Validates and updates state</span>
engine.moveClip(clipId, newStart) <span class="c">// Supports undo/redo</span>
engine.undo()                    <span class="c">// Revert last operation</span>
engine.redo()                    <span class="c">// Reapply operation</span>

<span class="c">// Subscribe to state changes</span>
<span class="k">const</span> <span class="v">unsubscribe</span> = engine.subscribe((<span class="v">state</span>) => {
  console.log(<span class="s">'State changed:'</span>, state)
})</pre>
      </div>

      <div class="callout callout-info">
        <div class="callout-title">üí° Public vs Internal API</div>
        <p><strong>Public API</strong> (from <code>@timeline/core</code>): TimelineEngine, factory functions, types, frame utilities</p>
        <p><strong>Internal API</strong> (from <code>@timeline/core/internal</code>): Low-level operations, systems, utilities ‚Äî used by tests and advanced integrations</p>
      </div>

      <h4>2. Adapter Layer (@timeline/react) - Framework Integration</h4>
      <p>The React adapter provides hooks and context for state management:</p>
      <ul>
        <li><strong>TimelineProvider</strong> ‚Äî Context provider wrapping the engine</li>
        <li><strong>useEngine()</strong> ‚Äî Access the engine instance</li>
        <li><strong>useTimeline()</strong> ‚Äî Subscribe to full timeline state</li>
        <li><strong>useTrack(trackId)</strong> ‚Äî Subscribe to specific track</li>
        <li><strong>useClip(clipId)</strong> ‚Äî Subscribe to specific clip</li>
        <li><strong>Optimized subscriptions</strong> ‚Äî Listeners receive state directly</li>
      </ul>

      <div class="code-block">
        <div class="code-header">
          <span class="code-filename">packages/react/src/hooks/useTimeline.ts</span>
          <span class="code-lang">typescript</span>
        </div>
        <pre><span class="k">import</span> { TimelineProvider, useTimeline, useEngine } <span class="k">from</span> <span class="s">'@timeline/react'</span>

<span class="c">// Wrap app with provider</span>
<span class="k">function</span> <span class="f">App</span>() {
  <span class="k">return</span> (
    <span class="p">&lt;</span><span class="t">TimelineProvider</span> <span class="v">engine</span>={engine}<span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="t">TimelineView</span> <span class="p">/&gt;</span>
    <span class="p">&lt;/</span><span class="t">TimelineProvider</span><span class="p">&gt;</span>
  )
}

<span class="c">// Use hooks in components</span>
<span class="k">function</span> <span class="f">TimelineView</span>() {
  <span class="k">const</span> { state } = useTimeline()        <span class="c">// Full state</span>
  <span class="k">const</span> <span class="v">engine</span> = useEngine()              <span class="c">// Engine instance</span>
  <span class="k">const</span> <span class="v">track</span> = useTrack(<span class="s">'track-1'</span>)     <span class="c">// Specific track</span>
  
  <span class="k">return</span> <span class="p">&lt;</span><span class="t">div</span><span class="p">&gt;</span>{<span class="c">/* UI */</span>}<span class="p">&lt;/</span><span class="t">div</span><span class="p">&gt;</span>
}</pre>
      </div>

      <h4>3. UI Layer (@timeline/ui) - Components</h4>
      <p>Pre-built components with local state management for UI interactions:</p>
      <ul>
        <li><strong>Timeline</strong> ‚Äî Main component managing playhead, zoom, snapping, selection</li>
        <li><strong>Track</strong> ‚Äî Track component with mute/solo/lock controls</li>
        <li><strong>Clip</strong> ‚Äî Draggable, resizable clip with selection</li>
        <li><strong>TimeRuler</strong> ‚Äî Time ruler with click-to-seek</li>
        <li><strong>Local UI state</strong> ‚Äî Managed in Timeline component, not in engine</li>
        <li><strong>Keyboard shortcuts</strong> ‚Äî Full support for all operations</li>
      </ul>

      <div class="code-block">
        <div class="code-header">
          <span class="code-filename">packages/ui/src/timeline/Timeline.tsx</span>
          <span class="code-lang">typescript</span>
        </div>
        <pre><span class="c">// Timeline manages local UI state</span>
<span class="k">export function</span> <span class="f">Timeline</span>() {
  <span class="k">const</span> { state } = useTimeline()
  <span class="k">const</span> <span class="v">engine</span> = useEngine()
  
  <span class="c">// Local UI state (not in engine)</span>
  <span class="k">const</span> [<span class="v">playhead</span>, <span class="v">setPlayhead</span>] = useState(frame(<span class="n">0</span>))
  <span class="k">const</span> [<span class="v">pixelsPerFrame</span>, <span class="v">setPixelsPerFrame</span>] = useState(<span class="n">1</span>)
  <span class="k">const</span> [<span class="v">snappingEnabled</span>, <span class="v">setSnappingEnabled</span>] = useState(<span class="k">true</span>)
  <span class="k">const</span> [<span class="v">editingMode</span>, <span class="v">setEditingMode</span>] = useState(<span class="s">'normal'</span>)
  <span class="k">const</span> [<span class="v">selectedClipIds</span>, <span class="v">setSelectedClipIds</span>] = useState(<span class="k">new</span> Set())
  
  <span class="c">// Keyboard shortcuts</span>
  useEffect(() => {
    <span class="k">const</span> <span class="f">handleKeyDown</span> = (<span class="v">e</span>) => {
      <span class="k">if</span> (e.key === <span class="s">'Delete'</span>) {
        selectedClipIds.forEach(<span class="v">id</span> => engine.removeClip(id))
      }
      <span class="c">// ... more shortcuts</span>
    }
    document.addEventListener(<span class="s">'keydown'</span>, handleKeyDown)
  }, [selectedClipIds])
  
  <span class="k">return</span> <span class="p">&lt;</span><span class="t">div</span><span class="p">&gt;</span>{<span class="c">/* Render timeline */</span>}<span class="p">&lt;/</span><span class="t">div</span><span class="p">&gt;</span>
}</pre>
      </div>

      <div class="callout callout-success">
        <div class="callout-title">‚úÖ Why This Architecture Works</div>
        <p><strong>Clear separation:</strong> Engine handles timeline data and operations. React adapter manages subscriptions. UI components handle user interactions and visual state.</p>
        <p><strong>Flexible UI state:</strong> Playhead, zoom, and selection live in UI (not engine) because they're view-specific and shouldn't be in undo/redo history.</p>
        <p><strong>Testable:</strong> Core engine is 100% testable without React. UI components can be tested with React Testing Library.</p>
      </div>
    </div>

    <hr>

    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
    <!-- HOW TIMELINE WORKS -->
    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->

    <div class="section" id="how-timeline-works">
      <div class="section-tag">Chapter 4</div>
      <h2>How Timeline Works: First Principles</h2>
      <p class="section-intro">
        Before writing code, you need to deeply understand what a timeline actually <em>is</em> and how it <em>behaves</em>. Let's build this mental model from the ground up.
      </p>

      <h3>The Fundamental Concept</h3>
      <p>A timeline is a <strong>2D coordinate system</strong> where:</p>
      <ul>
        <li><strong>X-axis = Time</strong> (measured in seconds, frames, or milliseconds)</li>
        <li><strong>Y-axis = Tracks</strong> (layers of content stacked vertically)</li>
      </ul>

      <p>Every piece of content (video clip, audio clip, image, text) is a <strong>rectangle</strong> in this 2D space:</p>
      <ul>
        <li><strong>X position</strong> = when it starts (e.g., 5.2 seconds)</li>
        <li><strong>Width</strong> = how long it plays (e.g., 3.0 seconds)</li>
        <li><strong>Y position</strong> = which track it's on (e.g., track 2)</li>
      </ul>

      <h3>Core Timeline Behaviors</h3>
      <p>Users interact with timelines in specific ways. You need to support all of these:</p>

      <h4>1. Playback Control</h4>
      <ul>
        <li><strong>Play/Pause</strong> ‚Äî Move playhead forward at constant speed</li>
        <li><strong>Scrubbing</strong> ‚Äî Drag playhead to jump to specific time</li>
        <li><strong>Step Forward/Back</strong> ‚Äî Move playhead by 1 frame</li>
        <li><strong>Jump to Edit Points</strong> ‚Äî Snap playhead to clip boundaries</li>
      </ul>

      <h4>2. Clip Manipulation</h4>
      <ul>
        <li><strong>Move</strong> ‚Äî Drag clip horizontally (change start time)</li>
        <li><strong>Move to Track</strong> ‚Äî Drag clip vertically (change layer)</li>
        <li><strong>Trim Start</strong> ‚Äî Drag left edge to change in-point</li>
        <li><strong>Trim End</strong> ‚Äî Drag right edge to change out-point</li>
        <li><strong>Split</strong> ‚Äî Cut clip at playhead position into two clips</li>
        <li><strong>Delete</strong> ‚Äî Remove clip entirely</li>
        <li><strong>Duplicate</strong> ‚Äî Copy clip to new position</li>
      </ul>

      <h4>3. Track Management</h4>
      <ul>
        <li><strong>Add Track</strong> ‚Äî Create new layer</li>
        <li><strong>Delete Track</strong> ‚Äî Remove layer (what happens to clips?)</li>
        <li><strong>Reorder Tracks</strong> ‚Äî Change stacking order</li>
        <li><strong>Lock/Unlock</strong> ‚Äî Prevent accidental edits</li>
        <li><strong>Mute/Solo</strong> ‚Äî Control audio/video visibility</li>
      </ul>

      <h4>4. Zoom & Pan</h4>
      <ul>
        <li><strong>Zoom In/Out</strong> ‚Äî Change time scale (pixels per second)</li>
        <li><strong>Pan Left/Right</strong> ‚Äî Scroll through time</li>
        <li><strong>Fit to View</strong> ‚Äî Zoom to show entire timeline</li>
        <li><strong>Zoom to Selection</strong> ‚Äî Focus on selected clips</li>
      </ul>

      <h3>The Math Behind It</h3>
      <p>Every timeline operation is just math. Here are the key calculations:</p>

      <h4>Time to Pixels</h4>
      <div class="code-block">
        <div class="code-header">
          <span class="code-filename">Time-to-pixel conversion</span>
          <span class="code-lang">typescript</span>
        </div>
        <pre><span class="c">// Given: time in seconds, zoom level (pixels per second)</span>
<span class="k">function</span> <span class="f">timeToPixels</span>(<span class="v">time</span>: <span class="t">number</span>, <span class="v">zoom</span>: <span class="t">number</span>): <span class="t">number</span> {
  <span class="k">return</span> time * zoom
}

<span class="c">// Example: 5 seconds at 100px/sec = 500px from timeline start</span>
<span class="k">const</span> <span class="v">x</span> = timeToPixels(<span class="n">5</span>, <span class="n">100</span>) <span class="c">// 500</span></pre>
      </div>

      <h4>Pixels to Time</h4>
      <div class="code-block">
        <div class="code-header">
          <span class="code-filename">Pixel-to-time conversion</span>
          <span class="code-lang">typescript</span>
        </div>
        <pre><span class="c">// Inverse operation: convert mouse X position to time</span>
<span class="k">function</span> <span class="f">pixelsToTime</span>(<span class="v">pixels</span>: <span class="t">number</span>, <span class="v">zoom</span>: <span class="t">number</span>): <span class="t">number</span> {
  <span class="k">return</span> pixels / zoom
}

<span class="c">// Example: Clicked at 750px with 100px/sec zoom = 7.5 seconds</span>
<span class="k">const</span> <span class="v">time</span> = pixelsToTime(<span class="n">750</span>, <span class="n">100</span>) <span class="c">// 7.5</span></pre>
      </div>

      <h4>Snap to Grid</h4>
      <div class="code-block">
        <div class="code-header">
          <span class="code-filename">Snapping behavior</span>
          <span class="code-lang">typescript</span>
        </div>
        <pre><span class="c">// Snap time to nearest grid interval (e.g., 0.1 second increments)</span>
<span class="k">function</span> <span class="f">snapToGrid</span>(<span class="v">time</span>: <span class="t">number</span>, <span class="v">gridSize</span>: <span class="t">number</span>): <span class="t">number</span> {
  <span class="k">return</span> <span class="t">Math</span>.round(time / gridSize) * gridSize
}

<span class="c">// Example: 5.23 seconds snaps to 5.2 with 0.1 grid</span>
<span class="k">const</span> <span class="v">snapped</span> = snapToGrid(<span class="n">5.23</span>, <span class="n">0.1</span>) <span class="c">// 5.2</span></pre>
      </div>

      <h4>Clip Collision Detection</h4>
      <div class="code-block">
        <div class="code-header">
          <span class="code-filename">Check if clips overlap</span>
          <span class="code-lang">typescript</span>
        </div>
        <pre><span class="c">// Do two clips overlap in time?</span>
<span class="k">function</span> <span class="f">clipsOverlap</span>(<span class="v">clip1</span>: <span class="t">Clip</span>, <span class="v">clip2</span>: <span class="t">Clip</span>): <span class="t">boolean</span> {
  <span class="k">const</span> <span class="v">end1</span> = clip1.start + clip1.duration
  <span class="k">const</span> <span class="v">end2</span> = clip2.start + clip2.duration
  
  <span class="c">// Check if they're on same track AND time ranges overlap</span>
  <span class="k">return</span> clip1.trackId === clip2.trackId &&
         clip1.start < end2 &&
         clip2.start < end1
}</pre>
      </div>

      <div class="callout callout-info">
        <div class="callout-title">üí° Everything is Rectangles</div>
        <p>Once you understand that timeline editing is just <strong>moving rectangles in 2D space with constraints</strong>, the entire problem becomes much simpler. All the complex UI interactions (drag, resize, snap) are just math operations on rectangle coordinates.</p>
      </div>
    </div>

    <hr>

    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
    <!-- DATA MODEL -->
    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->

    <div class="section" id="data-model">
      <div class="section-tag">Chapter 5</div>
      <h2>Data Model: Your Timeline Schema</h2>
      <p class="section-intro">
        The data model is the <strong>single source of truth</strong> for your entire library. Get this right and everything flows naturally. Get it wrong and you'll constantly fight your own architecture.
      </p>

      <h3>Core Type Definitions</h3>
      <p>Here's the complete type system for your timeline library:</p>

      <div class="code-block">
        <div class="code-header">
          <span class="code-filename">packages/core/src/types.ts</span>
          <span class="code-lang">typescript</span>
        </div>
        <pre><span class="c">// ‚ïê‚ïê‚ïê TIMELINE ‚ïê‚ïê‚ïê</span>
<span class="k">export interface</span> <span class="t">Timeline</span> {
  <span class="v">id</span>: <span class="t">string</span>
  <span class="v">tracks</span>: <span class="t">Track</span>[]
  <span class="v">duration</span>: <span class="t">number</span>          <span class="c">// Total timeline duration in seconds</span>
  <span class="v">frameRate</span>: <span class="t">number</span>        <span class="c">// FPS (e.g., 30, 60)</span>
  <span class="v">sampleRate</span>?: <span class="t">number</span>      <span class="c">// For audio (e.g., 44100, 48000)</span>
  <span class="v">metadata</span>?: <span class="t">Record</span>&lt;<span class="t">string</span>, <span class="t">any</span>&gt;
}

<span class="c">// ‚ïê‚ïê‚ïê TRACK ‚ïê‚ïê‚ïê</span>
<span class="k">export interface</span> <span class="t">Track</span> {
  <span class="v">id</span>: <span class="t">string</span>
  <span class="v">name</span>: <span class="t">string</span>
  <span class="v">type</span>: <span class="s">'video'</span> | <span class="s">'audio'</span> | <span class="s">'subtitle'</span> | <span class="s">'custom'</span>
  <span class="v">clips</span>: <span class="t">Clip</span>[]
  <span class="v">height</span>: <span class="t">number</span>           <span class="c">// Track height in pixels</span>
  <span class="v">locked</span>: <span class="t">boolean</span>          <span class="c">// Prevent editing</span>
  <span class="v">visible</span>: <span class="t">boolean</span>         <span class="c">// Show/hide track</span>
  <span class="v">muted</span>: <span class="t">boolean</span>           <span class="c">// Mute audio</span>
  <span class="v">order</span>: <span class="t">number</span>            <span class="c">// Stack order (0 = bottom)</span>
  <span class="v">color</span>?: <span class="t">string</span>           <span class="c">// Visual theme color</span>
}

<span class="c">// ‚ïê‚ïê‚ïê CLIP ‚ïê‚ïê‚ïê</span>
<span class="k">export interface</span> <span class="t">Clip</span> {
  <span class="v">id</span>: <span class="t">string</span>
  <span class="v">trackId</span>: <span class="t">string</span>          <span class="c">// Which track owns this clip</span>
  <span class="v">name</span>: <span class="t">string</span>
  <span class="v">type</span>: <span class="s">'video'</span> | <span class="s">'audio'</span> | <span class="s">'image'</span> | <span class="s">'text'</span> | <span class="s">'custom'</span>
  
  <span class="c">// Timing</span>
  <span class="v">start</span>: <span class="t">number</span>            <span class="c">// Start time on timeline (seconds)</span>
  <span class="v">duration</span>: <span class="t">number</span>        <span class="c">// How long clip plays (seconds)</span>
  
  <span class="c">// Source trimming (for video/audio files)</span>
  <span class="v">trimStart</span>: <span class="t">number</span>        <span class="c">// Where to start in source file</span>
  <span class="v">trimEnd</span>: <span class="t">number</span>          <span class="c">// Where to end in source file</span>
  
  <span class="c">// Source reference</span>
  <span class="v">sourceUrl</span>?: <span class="t">string</span>       <span class="c">// URL to media file</span>
  <span class="v">sourceId</span>?: <span class="t">string</span>        <span class="c">// Reference to media asset</span>
  
  <span class="c">// Effects and properties</span>
  <span class="v">effects</span>: <span class="t">Effect</span>[]
  <span class="v">properties</span>: <span class="t">ClipProperties</span>
  
  <span class="c">// Visual</span>
  <span class="v">color</span>?: <span class="t">string</span>
  <span class="v">thumbnail</span>?: <span class="t">string</span>      <span class="c">// Preview image URL</span>
}

<span class="c">// ‚ïê‚ïê‚ïê CLIP PROPERTIES ‚ïê‚ïê‚ïê</span>
<span class="k">export interface</span> <span class="t">ClipProperties</span> {
  <span class="v">opacity</span>: <span class="t">number</span>          <span class="c">// 0-1</span>
  <span class="v">volume</span>: <span class="t">number</span>           <span class="c">// 0-1 (for audio)</span>
  <span class="v">speed</span>: <span class="t">number</span>            <span class="c">// Playback speed multiplier</span>
  <span class="v">position</span>: { <span class="v">x</span>: <span class="t">number</span>; <span class="v">y</span>: <span class="t">number</span> }
  <span class="v">scale</span>: { <span class="v">x</span>: <span class="t">number</span>; <span class="v">y</span>: <span class="t">number</span> }
  <span class="v">rotation</span>: <span class="t">number</span>         <span class="c">// Degrees</span>
  <span class="v">keyframes</span>: <span class="t">Keyframe</span>[]
}

<span class="c">// ‚ïê‚ïê‚ïê KEYFRAME ‚ïê‚ïê‚ïê</span>
<span class="k">export interface</span> <span class="t">Keyframe</span> {
  <span class="v">id</span>: <span class="t">string</span>
  <span class="v">time</span>: <span class="t">number</span>             <span class="c">// Relative to clip start</span>
  <span class="v">property</span>: <span class="t">string</span>        <span class="c">// e.g., 'opacity', 'position.x'</span>
  <span class="v">value</span>: <span class="t">number</span> | { <span class="v">x</span>: <span class="t">number</span>; <span class="v">y</span>: <span class="t">number</span> }
  <span class="v">easing</span>: <span class="s">'linear'</span> | <span class="s">'easeIn'</span> | <span class="s">'easeOut'</span> | <span class="s">'easeInOut'</span>
}

<span class="c">// ‚ïê‚ïê‚ïê EFFECT ‚ïê‚ïê‚ïê</span>
<span class="k">export interface</span> <span class="t">Effect</span> {
  <span class="v">id</span>: <span class="t">string</span>
  <span class="v">type</span>: <span class="t">string</span>             <span class="c">// 'blur', 'brightness', 'fadeIn', etc.</span>
  <span class="v">enabled</span>: <span class="t">boolean</span>
  <span class="v">parameters</span>: <span class="t">Record</span>&lt;<span class="t">string</span>, <span class="t">any</span>&gt;
}</pre>
      </div>

      <h3>Design Principles</h3>
      <div class="feature-grid">
        <div class="feature-card">
          <span class="feature-icon">üîí</span>
          <h4>Immutable</h4>
          <p>All data structures are readonly. Functions return new objects, never mutate inputs. This makes undo/redo trivial.</p>
        </div>

        <div class="feature-card">
          <span class="feature-icon">üÜî</span>
          <h4>ID-Based References</h4>
          <p>Clips reference tracks by ID, not by index. This makes reordering tracks safe and prevents stale references.</p>
        </div>

        <div class="feature-card">
          <span class="feature-icon">üé®</span>
          <h4>Extensible</h4>
          <p>Custom metadata fields on every type. Users can store their own data without modifying your types.</p>
        </div>

        <div class="feature-card">
          <span class="feature-icon">‚ö°</span>
          <h4>Normalized</h4>
          <p>Flat structure where possible. Tracks contain clip IDs, not nested clip objects. Easier to query and update.</p>
        </div>
      </div>

      <div class="callout callout-warning">
        <div class="callout-title">‚ö†Ô∏è Critical: Don't Over-Design</div>
        <p>You might be tempted to add 50 more fields "just in case." <strong>Don't.</strong> Start minimal. Add fields only when you have a concrete use case. You can always add fields later (breaking change), but removing them is painful.</p>
        <p>The schema above is everything you need for a production timeline library.</p>
      </div>
    </div>

    <hr>

    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
    <!-- STATE MANAGEMENT -->
    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->

    <div class="section" id="state-management">
      <div class="section-tag">Chapter 6</div>
      <h2>State Management Strategy</h2>
      <p class="section-intro">
        How you manage timeline state determines the entire developer experience. This is where most timeline libraries fail. Here's how to do it right.
      </p>

      <h3>The Core Principle: Unidirectional Data Flow</h3>
      <p>Your timeline state flows in one direction:</p>
      <div class="code-block">
        <div class="code-header">
          <span class="code-filename">State flow pattern</span>
          <span class="code-lang">plaintext</span>
        </div>
        <pre>User Action (drag clip)
    ‚Üì
Core Function (moveClip)
    ‚Üì
New Timeline State
    ‚Üì
React Re-render
    ‚Üì
Updated UI</pre>
      </div>

      <h3>Immutability Pattern</h3>
      <p>Every state update creates a NEW timeline object:</p>

      <div class="code-block">
        <div class="code-header">
          <span class="code-filename">Immutable update pattern</span>
          <span class="code-lang">typescript</span>
        </div>
        <pre><span class="c">// ‚úÖ CORRECT: Pure function returns new object</span>
<span class="k">function</span> <span class="f">moveClip</span>(<span class="v">timeline</span>: <span class="t">Timeline</span>, <span class="v">clipId</span>, <span class="v">newStart</span>): <span class="t">Timeline</span> {
  <span class="k">const</span> <span class="v">newTracks</span> = timeline.tracks.map(<span class="v">track</span> => ({
    ...track,
    clips: track.clips.map(<span class="v">clip</span> =>
      clip.id === clipId ? { ...clip, start: newStart } : clip
    )
  }))
  
  <span class="k">return</span> { ...timeline, tracks: newTracks }
}

<span class="c">// ‚ùå WRONG: Mutates input directly</span>
<span class="k">function</span> <span class="f">moveClip</span>(<span class="v">timeline</span>, <span class="v">clipId</span>, <span class="v">newStart</span>) {
  <span class="k">const</span> <span class="v">clip</span> = timeline.tracks[<span class="n">0</span>].clips[<span class="n">0</span>]
  clip.start = newStart <span class="c">// BAD! Mutation!</span>
  <span class="k">return</span> timeline
}</pre>
      </div>

      <h3>Undo/Redo Implementation</h3>
      <p>With immutable state, undo/redo is <strong>trivial</strong>:</p>

      <div class="code-block">
        <div class="code-header">
          <span class="code-filename">Simple undo/redo with immutable state</span>
          <span class="code-lang">typescript</span>
        </div>
        <pre><span class="k">export function</span> <span class="f">useHistory</span>&lt;<span class="t">T</span>&gt;(<span class="v">initialState</span>: <span class="t">T</span>) {
  <span class="k">const</span> [<span class="v">past</span>, <span class="v">setPast</span>] = useState&lt;<span class="t">T</span>[]&gt;([])
  <span class="k">const</span> [<span class="v">present</span>, <span class="v">setPresent</span>] = useState(<span class="v">initialState</span>)
  <span class="k">const</span> [<span class="v">future</span>, <span class="v">setFuture</span>] = useState&lt;<span class="t">T</span>[]&gt;([])
  
  <span class="k">const</span> <span class="f">push</span> = (<span class="v">newState</span>: <span class="t">T</span>) => {
    setPast([...past, present])
    setPresent(newState)
    setFuture([]) <span class="c">// Clear future on new action</span>
  }
  
  <span class="k">const</span> <span class="f">undo</span> = () => {
    <span class="k">if</span> (past.length === <span class="n">0</span>) <span class="k">return</span>
    <span class="k">const</span> <span class="v">previous</span> = past[past.length - <span class="n">1</span>]
    setPast(past.slice(<span class="n">0</span>, -<span class="n">1</span>))
    setFuture([present, ...future])
    setPresent(previous)
  }
  
  <span class="k">const</span> <span class="f">redo</span> = () => {
    <span class="k">if</span> (future.length === <span class="n">0</span>) <span class="k">return</span>
    <span class="k">const</span> <span class="v">next</span> = future[<span class="n">0</span>]
    setPast([...past, present])
    setPresent(next)
    setFuture(future.slice(<span class="n">1</span>))
  }
  
  <span class="k">return</span> { state: present, push, undo, redo, canUndo: past.length > <span class="n">0</span>, canRedo: future.length > <span class="n">0</span> }
}</pre>
      </div>

      <p>That's it. ~30 lines for full undo/redo. Because state is immutable, you just swap timeline objects.</p>

      <h3>Performance Optimization</h3>
      <p>Immutability can cause unnecessary re-renders. Here's how to optimize:</p>

      <h4>1. Memoization</h4>
      <div class="code-block">
        <div class="code-header">
          <span class="code-filename">Memoize expensive calculations</span>
          <span class="code-lang">typescript</span>
        </div>
        <pre><span class="k">import</span> { useMemo } <span class="k">from</span> <span class="s">'react'</span>

<span class="k">function</span> <span class="f">Timeline</span>({ <span class="v">timeline</span> }) {
  <span class="c">// Only recalculate when timeline.tracks changes</span>
  <span class="k">const</span> <span class="v">sortedTracks</span> = useMemo(
    () => timeline.tracks.slice().sort((<span class="v">a</span>, <span class="v">b</span>) => a.order - b.order),
    [timeline.tracks]
  )
  
  <span class="k">return</span> <span class="p">&lt;</span><span class="t">div</span><span class="p">&gt;</span>{<span class="c">/* render tracks */</span>}<span class="p">&lt;/</span><span class="t">div</span><span class="p">&gt;</span>
}</pre>
      </div>

      <h4>2. React.memo for Components</h4>
      <div class="code-block">
        <div class="code-header">
          <span class="code-filename">Prevent unnecessary re-renders</span>
          <span class="code-lang">typescript</span>
        </div>
        <pre><span class="k">const</span> <span class="t">Clip</span> = <span class="t">React</span>.memo(({ <span class="v">clip</span>, <span class="v">onMove</span> }) => {
  <span class="c">// Only re-renders when clip props actually change</span>
  <span class="k">return</span> <span class="p">&lt;</span><span class="t">div</span><span class="p">&gt;</span>{clip.name}<span class="p">&lt;/</span><span class="t">div</span><span class="p">&gt;</span>
})</pre>
      </div>

      <h4>3. Virtualization for Large Timelines</h4>
      <div class="code-block">
        <div class="code-header">
          <span class="code-filename">Only render visible clips</span>
          <span class="code-lang">typescript</span>
        </div>
        <pre><span class="k">import</span> { useVirtualizer } <span class="k">from</span> <span class="s">'@tanstack/react-virtual'</span>

<span class="k">function</span> <span class="f">Timeline</span>({ <span class="v">timeline</span> }) {
  <span class="k">const</span> <span class="v">rowVirtualizer</span> = useVirtualizer({
    count: timeline.tracks.length,
    getScrollElement: () => parentRef.current,
    estimateSize: () => <span class="n">64</span>, <span class="c">// Track height</span>
  })
  
  <span class="c">// Only render visible tracks</span>
  <span class="k">return</span> rowVirtualizer.getVirtualItems().map(<span class="v">virtualRow</span> => (
    <span class="p">&lt;</span><span class="t">Track</span> <span class="v">key</span>={virtualRow.key} <span class="v">track</span>={timeline.tracks[virtualRow.index]} <span class="p">/&gt;</span>
  ))
}</pre>
      </div>

      <div class="callout callout-success">
        <div class="callout-title">‚úÖ State Management Best Practices</div>
        <ul>
          <li><strong>Keep state minimal</strong> ‚Äî Store only source data, derive everything else</li>
          <li><strong>Normalize data</strong> ‚Äî Use IDs for references, not nested objects</li>
          <li><strong>Batch updates</strong> ‚Äî Update multiple things in one setState call</li>
          <li><strong>Profile before optimizing</strong> ‚Äî Don't add complexity until you measure a problem</li>
        </ul>
      </div>
    </div>

    <hr>

    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
    <!-- MONOREPO SETUP -->
    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->

    <div class="section" id="monorepo">
      <div class="section-tag">Chapter 7</div>
      <h2>Monorepo Setup</h2>
      <p class="section-intro">
        Your timeline library needs a monorepo structure to manage multiple packages (core, react, vue, cli, docs). Here's exactly how to set it up.
      </p>

      <h3>Why Monorepo?</h3>
      <p>A monorepo lets you:</p>
      <ul>
        <li><strong>Share code easily</strong> ‚Äî All packages can import from @timeline/core</li>
        <li><strong>Version together</strong> ‚Äî Release all packages in sync</li>
        <li><strong>Test together</strong> ‚Äî Run all tests with one command</li>
        <li><strong>Develop faster</strong> ‚Äî No need to publish/install during development</li>
      </ul>

      <h3>Recommended Tool: Turborepo</h3>
      <p>Use Turborepo (by Vercel). It's what shadcn/ui uses, it's fast, and it handles caching beautifully.</p>

      <h4>Initial Setup</h4>
      <div class="code-block">
        <div class="code-header">
          <span class="code-filename">Terminal</span>
          <span class="code-lang">bash</span>
        </div>
        <pre><span class="c"># Create new project</span>
npx create-turbo@latest timeline-library

<span class="c"># Or manually:</span>
mkdir timeline-library
cd timeline-library
npm init -y
npm install turbo --save-dev</pre>
      </div>

      <h4>Folder Structure</h4>
      <div class="code-block">
        <div class="code-header">
          <span class="code-filename">Complete monorepo structure</span>
          <span class="code-lang">plaintext</span>
        </div>
        <pre>timeline-library/
‚îú‚îÄ‚îÄ packages/
‚îÇ   ‚îú‚îÄ‚îÄ core/                 # @timeline/core
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ types.ts      # All TypeScript types
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mutations.ts  # State update functions
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ queries.ts    # Read-only query functions
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ utils.ts      # Time conversion, snapping, etc.
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.ts      # Public exports
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ package.json
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ tsconfig.json
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ react/                # @timeline/react
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ hooks/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ useTimeline.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ useHistory.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ useDrag.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ usePlayback.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ useZoom.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ package.json
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ tsconfig.json
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ vue/                  # @timeline/vue (future)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ cli/                  # timeline-cli
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ commands/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ init.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ add.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ registry.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ installer.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ framework-detector.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ package.json
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ tsconfig.json
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ tsconfig/             # Shared TypeScript configs
‚îÇ       ‚îú‚îÄ‚îÄ base.json
‚îÇ       ‚îú‚îÄ‚îÄ react.json
‚îÇ       ‚îî‚îÄ‚îÄ node.json
‚îÇ
‚îú‚îÄ‚îÄ apps/
‚îÇ   ‚îú‚îÄ‚îÄ docs/                 # Documentation site
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Next.js or Astro
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ playground/           # Demo/testing app
‚îÇ       ‚îú‚îÄ‚îÄ React app
‚îÇ       ‚îî‚îÄ‚îÄ ...
‚îÇ
‚îú‚îÄ‚îÄ registry/                 # Component source files
‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ timeline.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ track.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ clip.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ playhead.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ruler.tsx
‚îÇ   ‚îî‚îÄ‚îÄ registry.json         # Component metadata
‚îÇ
‚îú‚îÄ‚îÄ turbo.json               # Turbo configuration
‚îú‚îÄ‚îÄ package.json             # Root package.json
‚îî‚îÄ‚îÄ pnpm-workspace.yaml      # PNPM workspace config</pre>
      </div>

      <h4>Root package.json</h4>
      <div class="code-block">
        <div class="code-header">
          <span class="code-filename">package.json</span>
          <span class="code-lang">json</span>
        </div>
        <pre>{
  <span class="s">"name"</span>: <span class="s">"timeline-library"</span>,
  <span class="s">"private"</span>: <span class="k">true</span>,
  <span class="s">"scripts"</span>: {
    <span class="s">"build"</span>: <span class="s">"turbo run build"</span>,
    <span class="s">"dev"</span>: <span class="s">"turbo run dev"</span>,
    <span class="s">"test"</span>: <span class="s">"turbo run test"</span>,
    <span class="s">"lint"</span>: <span class="s">"turbo run lint"</span>,
    <span class="s">"format"</span>: <span class="s">"prettier --write \"**/*.{ts,tsx,md}\""</span>
  },
  <span class="s">"devDependencies"</span>: {
    <span class="s">"turbo"</span>: <span class="s">"latest"</span>,
    <span class="s">"typescript"</span>: <span class="s">"^5.3.0"</span>,
    <span class="s">"prettier"</span>: <span class="s">"^3.1.0"</span>,
    <span class="s">"eslint"</span>: <span class="s">"^8.55.0"</span>
  },
  <span class="s">"packageManager"</span>: <span class="s">"pnpm@8.0.0"</span>
}</pre>
      </div>

      <h4>turbo.json Configuration</h4>
      <div class="code-block">
        <div class="code-header">
          <span class="code-filename">turbo.json</span>
          <span class="code-lang">json</span>
        </div>
        <pre>{
  <span class="s">"$schema"</span>: <span class="s">"https://turbo.build/schema.json"</span>,
  <span class="s">"globalDependencies"</span>: [<span class="s">"**/.env.*local"</span>],
  <span class="s">"pipeline"</span>: {
    <span class="s">"build"</span>: {
      <span class="s">"dependsOn"</span>: [<span class="s">"^build"</span>],
      <span class="s">"outputs"</span>: [<span class="s">"dist/**"</span>, <span class="s">".next/**"</span>, <span class="s">"!.next/cache/**"</span>]
    },
    <span class="s">"test"</span>: {
      <span class="s">"dependsOn"</span>: [<span class="s">"build"</span>],
      <span class="s">"outputs"</span>: [<span class="s">"coverage/**"</span>]
    },
    <span class="s">"lint"</span>: {
      <span class="s">"outputs"</span>: []
    },
    <span class="s">"dev"</span>: {
      <span class="s">"cache"</span>: <span class="k">false</span>,
      <span class="s">"persistent"</span>: <span class="k">true</span>
    }
  }
}</pre>
      </div>

      <h4>Core Package Setup</h4>
      <div class="code-block">
        <div class="code-header">
          <span class="code-filename">packages/core/package.json</span>
          <span class="code-lang">json</span>
        </div>
        <pre>{
  <span class="s">"name"</span>: <span class="s">"@timeline/core"</span>,
  <span class="s">"version"</span>: <span class="s">"0.1.0"</span>,
  <span class="s">"main"</span>: <span class="s">"./dist/index.js"</span>,
  <span class="s">"module"</span>: <span class="s">"./dist/index.mjs"</span>,
  <span class="s">"types"</span>: <span class="s">"./dist/index.d.ts"</span>,
  <span class="s">"exports"</span>: {
    <span class="s">"."</span>: {
      <span class="s">"import"</span>: <span class="s">"./dist/index.mjs"</span>,
      <span class="s">"require"</span>: <span class="s">"./dist/index.js"</span>,
      <span class="s">"types"</span>: <span class="s">"./dist/index.d.ts"</span>
    }
  },
  <span class="s">"scripts"</span>: {
    <span class="s">"build"</span>: <span class="s">"tsup src/index.ts --format cjs,esm --dts"</span>,
    <span class="s">"dev"</span>: <span class="s">"tsup src/index.ts --format cjs,esm --dts --watch"</span>,
    <span class="s">"test"</span>: <span class="s">"vitest"</span>,
    <span class="s">"test:ui"</span>: <span class="s">"vitest --ui"</span>
  },
  <span class="s">"devDependencies"</span>: {
    <span class="s">"tsup"</span>: <span class="s">"^8.0.0"</span>,
    <span class="s">"vitest"</span>: <span class="s">"^1.0.0"</span>,
    <span class="s">"@timeline/tsconfig"</span>: <span class="s">"workspace:*"</span>
  }
}</pre>
      </div>

      <div class="callout callout-info">
        <div class="callout-title">üí° Why This Setup?</div>
        <ul>
          <li><strong>pnpm</strong> ‚Äî Faster than npm, better disk space usage, strict dependency resolution</li>
          <li><strong>Turborepo</strong> ‚Äî Caches builds, runs tasks in parallel, handles dependencies</li>
          <li><strong>tsup</strong> ‚Äî Zero-config TypeScript bundler, outputs CJS + ESM + types</li>
          <li><strong>Vitest</strong> ‚Äî Fast, Vite-powered test runner with great DX</li>
        </ul>
      </div>
    </div>

    <hr>

    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
    <!-- TECHNOLOGY CHOICES -->
    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->

    <div class="section" id="tech-choices">
      <div class="section-tag">Chapter 8</div>
      <h2>Technology Choices</h2>
      <p class="section-intro">
        Every technology choice has tradeoffs. Here's what to use and why, with alternatives explained.
      </p>

      <h3>Core Technologies (Required)</h3>

      <div class="decision-table">
        <table>
          <thead>
            <tr>
              <th>Technology</th>
              <th>Choice</th>
              <th>Why</th>
              <th>Alternatives</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><strong>Language</strong></td>
              <td>TypeScript 5.3+</td>
              <td class="good">Type safety, great DX, industry standard</td>
              <td class="bad">JavaScript (no types = pain)</td>
            </tr>
            <tr>
              <td><strong>Package Manager</strong></td>
              <td>pnpm</td>
              <td class="good">Fast, strict, disk-efficient</td>
              <td class="neutral">npm (slower), yarn (okay)</td>
            </tr>
            <tr>
              <td><strong>Monorepo</strong></td>
              <td>Turborepo</td>
              <td class="good">Fast builds, great caching, simple config</td>
              <td class="neutral">Nx (more complex), Lerna (outdated)</td>
            </tr>
            <tr>
              <td><strong>Bundler</strong></td>
              <td>tsup</td>
              <td class="good">Zero config, outputs CJS+ESM+types</td>
              <td class="neutral">Rollup (more config), tsc (no bundling)</td>
            </tr>
            <tr>
              <td><strong>Test Framework</strong></td>
              <td>Vitest</td>
              <td class="good">Fast, Vite-powered, great UI</td>
              <td class="neutral">Jest (slower), uvu (minimal)</td>
            </tr>
          </tbody>
        </table>
      </div>

      <h3>Framework Adapters</h3>

      <h4>React (@timeline/react)</h4>
      <div class="code-block">
        <div class="code-header">
          <span class="code-filename">packages/react/package.json</span>
          <span class="code-lang">json</span>
        </div>
        <pre>{
  <span class="s">"name"</span>: <span class="s">"@timeline/react"</span>,
  <span class="s">"peerDependencies"</span>: {
    <span class="s">"react"</span>: <span class="s">"^18.0.0"</span>,
    <span class="s">"react-dom"</span>: <span class="s">"^18.0.0"</span>
  },
  <span class="s">"dependencies"</span>: {
    <span class="s">"@timeline/core"</span>: <span class="s">"workspace:*"</span>
  }
}</pre>
      </div>

      <h4>Vue (@timeline/vue) - Future</h4>
      <div class="code-block">
        <div class="code-header">
          <span class="code-filename">packages/vue/package.json</span>
          <span class="code-lang">json</span>
        </div>
        <pre>{
  <span class="s">"name"</span>: <span class="s">"@timeline/vue"</span>,
  <span class="s">"peerDependencies"</span>: {
    <span class="s">"vue"</span>: <span class="s">"^3.3.0"</span>
  },
  <span class="s">"dependencies"</span>: {
    <span class="s">"@timeline/core"</span>: <span class="s">"workspace:*"</span>
  }
}</pre>
      </div>

      <h3>Component Development</h3>

      <div class="decision-table">
        <table>
          <thead>
            <tr>
              <th>Concern</th>
              <th>Choice</th>
              <th>Reasoning</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><strong>Styling</strong></td>
              <td>Tailwind CSS (optional)</td>
              <td class="good">Utility-first, users can override easily, optional</td>
            </tr>
            <tr>
              <td><strong>Primitives</strong></td>
              <td>Radix UI patterns</td>
              <td class="good">Accessible, composable, unstyled by default</td>
            </tr>
            <tr>
              <td><strong>Drag & Drop</strong></td>
              <td>Custom implementation</td>
              <td class="good">Full control, no heavy deps, exact behavior needed</td>
            </tr>
            <tr>
              <td><strong>Virtualization</strong></td>
              <td>@tanstack/react-virtual</td>
              <td class="good">Best-in-class, handles 1000s of items, framework-agnostic core</td>
            </tr>
          </tbody>
        </table>
      </div>

      <h3>CLI Tool Stack</h3>

      <div class="code-block">
        <div class="code-header">
          <span class="code-filename">packages/cli/package.json</span>
          <span class="code-lang">json</span>
        </div>
        <pre>{
  <span class="s">"name"</span>: <span class="s">"timeline-cli"</span>,
  <span class="s">"bin"</span>: {
    <span class="s">"timeline"</span>: <span class="s">"./dist/index.js"</span>
  },
  <span class="s">"dependencies"</span>: {
    <span class="s">"commander"</span>: <span class="s">"^11.1.0"</span>,      <span class="c">// CLI framework</span>
    <span class="s">"prompts"</span>: <span class="s">"^2.4.2"</span>,         <span class="c">// Interactive prompts</span>
    <span class="s">"chalk"</span>: <span class="s">"^5.3.0"</span>,           <span class="c">// Colored output</span>
    <span class="s">"ora"</span>: <span class="s">"^8.0.1"</span>,             <span class="c">// Spinners</span>
    <span class="s">"fs-extra"</span>: <span class="s">"^11.2.0"</span>,      <span class="c">// File operations</span>
    <span class="s">"execa"</span>: <span class="s">"^8.0.1"</span>            <span class="c">// Run shell commands</span>
  }
}</pre>
      </div>

      <h3>Documentation Site</h3>

      <div class="comparison">
        <div class="comparison-card highlight">
          <h4>Next.js (Recommended)</h4>
          <p><strong>Pros:</strong> MDX support, App Router, great SEO, Vercel deployment<br>
          <strong>Cons:</strong> Heavier, React-only</p>
        </div>
        <div class="comparison-card">
          <h4>Astro</h4>
          <p><strong>Pros:</strong> Super fast, framework-agnostic, great DX<br>
          <strong>Cons:</strong> Less mature, smaller ecosystem</p>
        </div>
        <div class="comparison-card">
          <h4>VitePress</h4>
          <p><strong>Pros:</strong> Vite-powered, Vue-based, simple<br>
          <strong>Cons:</strong> Less flexible than Next.js</p>
        </div>
      </div>

      <div class="callout callout-success">
        <div class="callout-title">‚úÖ Recommended Stack</div>
        <p><strong>For most developers:</strong></p>
        <ul>
          <li>TypeScript + pnpm + Turborepo</li>
          <li>Vitest for testing, tsup for building</li>
          <li>Next.js for docs (MDX + App Router)</li>
          <li>Tailwind CSS (optional) for component styling</li>
          <li>Commander.js for CLI</li>
        </ul>
        <p>This is battle-tested, well-documented, and has great community support.</p>
      </div>
    </div>

    <hr>

    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
    <!-- FRAMEWORK ADAPTERS -->
    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->

    <div class="section" id="framework-adapters">
      <div class="section-tag">Chapter 9</div>
      <h2>Framework Adapters</h2>
      <p class="section-intro">
        Adapters are the bridge between your pure core logic and framework-specific features. Here's how to build them for React, Vue, and beyond.
      </p>

      <h3>Adapter Design Pattern</h3>
      <p>Every adapter follows the same pattern:</p>
      <ol>
        <li><strong>Import core functions</strong> from @timeline/core</li>
        <li><strong>Wrap in framework primitives</strong> (hooks, composables, stores)</li>
        <li><strong>Handle reactivity</strong> so UI updates automatically</li>
        <li><strong>Manage side effects</strong> (playback, animations, etc.)</li>
      </ol>

      <h3>React Adapter</h3>

      <h4>useTimeline Hook</h4>
      <div class="code-block">
        <div class="code-header">
          <span class="code-filename">packages/react/src/hooks/useTimeline.ts</span>
          <span class="code-lang">typescript</span>
        </div>
        <pre><span class="k">import</span> { useState, useCallback } <span class="k">from</span> <span class="s">'react'</span>
<span class="k">import</span> {
  <span class="t">Timeline</span>,
  moveClip <span class="k">as</span> coreMoveClip,
  trimClip <span class="k">as</span> coreTrimClip,
  splitClip <span class="k">as</span> coreSplitClip,
  addTrack <span class="k">as</span> coreAddTrack,
  deleteClip <span class="k">as</span> coreDeleteClip
} <span class="k">from</span> <span class="s">'@timeline/core'</span>

<span class="k">export function</span> <span class="f">useTimeline</span>(<span class="v">initialTimeline</span>: <span class="t">Timeline</span>) {
  <span class="k">const</span> [<span class="v">timeline</span>, <span class="v">setTimeline</span>] = useState(<span class="v">initialTimeline</span>)

  <span class="c">// Wrap core functions with state updates</span>
  <span class="k">const</span> <span class="f">moveClip</span> = useCallback(
    (<span class="v">clipId</span>: <span class="t">string</span>, <span class="v">newStart</span>: <span class="t">number</span>, <span class="v">newTrackId</span>?: <span class="t">string</span>) => {
      setTimeline(<span class="v">prev</span> => coreMoveClip(prev, clipId, newStart, newTrackId))
    },
    []
  )

  <span class="k">const</span> <span class="f">trimClip</span> = useCallback(
    (<span class="v">clipId</span>: <span class="t">string</span>, <span class="v">newStart</span>?: <span class="t">number</span>, <span class="v">newDuration</span>?: <span class="t">number</span>) => {
      setTimeline(<span class="v">prev</span> => coreTrimClip(prev, clipId, newStart, newDuration))
    },
    []
  )

  <span class="k">const</span> <span class="f">splitClip</span> = useCallback(
    (<span class="v">clipId</span>: <span class="t">string</span>, <span class="v">splitTime</span>: <span class="t">number</span>) => {
      setTimeline(<span class="v">prev</span> => coreSplitClip(prev, clipId, splitTime))
    },
    []
  )

  <span class="k">const</span> <span class="f">addTrack</span> = useCallback((<span class="v">type</span>: <span class="s">'video'</span> | <span class="s">'audio'</span>) => {
    setTimeline(<span class="v">prev</span> => coreAddTrack(prev, type))
  }, [])

  <span class="k">const</span> <span class="f">deleteClip</span> = useCallback((<span class="v">clipId</span>: <span class="t">string</span>) => {
    setTimeline(<span class="v">prev</span> => coreDeleteClip(prev, clipId))
  }, [])

  <span class="k">return</span> {
    timeline,
    actions: {
      moveClip,
      trimClip,
      splitClip,
      addTrack,
      deleteClip
    }
  }
}</pre>
      </div>

      <h4>useHistory Hook (Undo/Redo)</h4>
      <div class="code-block">
        <div class="code-header">
          <span class="code-filename">packages/react/src/hooks/useHistory.ts</span>
          <span class="code-lang">typescript</span>
        </div>
        <pre><span class="k">import</span> { useState, useCallback } <span class="k">from</span> <span class="s">'react'</span>

<span class="k">export function</span> <span class="f">useHistory</span>&lt;<span class="t">T</span>&gt;(<span class="v">initialState</span>: <span class="t">T</span>) {
  <span class="k">const</span> [<span class="v">past</span>, <span class="v">setPast</span>] = useState&lt;<span class="t">T</span>[]&gt;([])
  <span class="k">const</span> [<span class="v">present</span>, <span class="v">setPresent</span>] = useState(<span class="v">initialState</span>)
  <span class="k">const</span> [<span class="v">future</span>, <span class="v">setFuture</span>] = useState&lt;<span class="t">T</span>[]&gt;([])

  <span class="k">const</span> <span class="f">push</span> = useCallback((<span class="v">newState</span>: <span class="t">T</span>) => {
    setPast(<span class="v">p</span> => [...p, present])
    setPresent(newState)
    setFuture([]) <span class="c">// Clear redo stack</span>
  }, [present])

  <span class="k">const</span> <span class="f">undo</span> = useCallback(() => {
    <span class="k">if</span> (past.length === <span class="n">0</span>) <span class="k">return</span>
    
    <span class="k">const</span> <span class="v">previous</span> = past[past.length - <span class="n">1</span>]
    <span class="k">const</span> <span class="v">newPast</span> = past.slice(<span class="n">0</span>, -<span class="n">1</span>)
    
    setPast(newPast)
    setFuture([present, ...future])
    setPresent(previous)
  }, [past, present, future])

  <span class="k">const</span> <span class="f">redo</span> = useCallback(() => {
    <span class="k">if</span> (future.length === <span class="n">0</span>) <span class="k">return</span>
    
    <span class="k">const</span> <span class="v">next</span> = future[<span class="n">0</span>]
    <span class="k">const</span> <span class="v">newFuture</span> = future.slice(<span class="n">1</span>)
    
    setPast([...past, present])
    setPresent(next)
    setFuture(newFuture)
  }, [past, present, future])

  <span class="k">const</span> <span class="f">reset</span> = useCallback(() => {
    setPast([])
    setFuture([])
  }, [])

  <span class="k">return</span> {
    state: present,
    push,
    undo,
    redo,
    reset,
    canUndo: past.length > <span class="n">0</span>,
    canRedo: future.length > <span class="n">0</span>
  }
}</pre>
      </div>

      <h4>usePlayback Hook</h4>
      <div class="code-block">
        <div class="code-header">
          <span class="code-filename">packages/react/src/hooks/usePlayback.ts</span>
          <span class="code-lang">typescript</span>
        </div>
        <pre><span class="k">import</span> { useState, useEffect, useCallback, useRef } <span class="k">from</span> <span class="s">'react'</span>

<span class="k">export function</span> <span class="f">usePlayback</span>(<span class="v">frameRate</span> = <span class="n">30</span>) {
  <span class="k">const</span> [<span class="v">currentTime</span>, <span class="v">setCurrentTime</span>] = useState(<span class="n">0</span>)
  <span class="k">const</span> [<span class="v">isPlaying</span>, <span class="v">setIsPlaying</span>] = useState(<span class="k">false</span>)
  <span class="k">const</span> <span class="v">animationFrameRef</span> = useRef&lt;<span class="t">number</span>&gt;()
  <span class="k">const</span> <span class="v">lastTimeRef</span> = useRef(<span class="t">Date</span>.now())

  <span class="c">// Playback loop</span>
  useEffect(() => {
    <span class="k">if</span> (!isPlaying) <span class="k">return</span>

    <span class="k">const</span> <span class="v">frameTime</span> = <span class="n">1000</span> / frameRate <span class="c">// milliseconds per frame</span>

    <span class="k">const</span> <span class="f">tick</span> = () => {
      <span class="k">const</span> <span class="v">now</span> = <span class="t">Date</span>.now()
      <span class="k">const</span> <span class="v">delta</span> = now - lastTimeRef.current

      <span class="k">if</span> (delta >= frameTime) {
        setCurrentTime(<span class="v">t</span> => t + (delta / <span class="n">1000</span>))
        lastTimeRef.current = now
      }

      animationFrameRef.current = requestAnimationFrame(tick)
    }

    animationFrameRef.current = requestAnimationFrame(tick)

    <span class="k">return</span> () => {
      <span class="k">if</span> (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
      }
    }
  }, [isPlaying, frameRate])

  <span class="k">const</span> <span class="f">play</span> = useCallback(() => {
    lastTimeRef.current = <span class="t">Date</span>.now()
    setIsPlaying(<span class="k">true</span>)
  }, [])

  <span class="k">const</span> <span class="f">pause</span> = useCallback(() => {
    setIsPlaying(<span class="k">false</span>)
  }, [])

  <span class="k">const</span> <span class="f">togglePlay</span> = useCallback(() => {
    setIsPlaying(<span class="v">p</span> => !p)
  }, [])

  <span class="k">const</span> <span class="f">seek</span> = useCallback((<span class="v">time</span>: <span class="t">number</span>) => {
    setCurrentTime(time)
    lastTimeRef.current = <span class="t">Date</span>.now()
  }, [])

  <span class="k">const</span> <span class="f">stepForward</span> = useCallback(() => {
    setCurrentTime(<span class="v">t</span> => t + (<span class="n">1</span> / frameRate))
  }, [frameRate])

  <span class="k">const</span> <span class="f">stepBackward</span> = useCallback(() => {
    setCurrentTime(<span class="v">t</span> => <span class="t">Math</span>.max(<span class="n">0</span>, t - (<span class="n">1</span> / frameRate)))
  }, [frameRate])

  <span class="k">return</span> {
    currentTime,
    isPlaying,
    play,
    pause,
    togglePlay,
    seek,
    stepForward,
    stepBackward
  }
}</pre>
      </div>

      <h3>Vue Adapter (Composables)</h3>
      <p>Vue uses composables instead of hooks. Here's the equivalent useTimeline:</p>

      <div class="code-block">
        <div class="code-header">
          <span class="code-filename">packages/vue/src/composables/useTimeline.ts</span>
          <span class="code-lang">typescript</span>
        </div>
        <pre><span class="k">import</span> { ref, readonly } <span class="k">from</span> <span class="s">'vue'</span>
<span class="k">import</span> {
  <span class="t">Timeline</span>,
  moveClip <span class="k">as</span> coreMoveClip,
  trimClip <span class="k">as</span> coreTrimClip
} <span class="k">from</span> <span class="s">'@timeline/core'</span>

<span class="k">export function</span> <span class="f">useTimeline</span>(<span class="v">initialTimeline</span>: <span class="t">Timeline</span>) {
  <span class="k">const</span> <span class="v">timeline</span> = ref(<span class="v">initialTimeline</span>)

  <span class="k">const</span> <span class="f">moveClip</span> = (<span class="v">clipId</span>: <span class="t">string</span>, <span class="v">newStart</span>: <span class="t">number</span>, <span class="v">newTrackId</span>?: <span class="t">string</span>) => {
    timeline.value = coreMoveClip(timeline.value, clipId, newStart, newTrackId)
  }

  <span class="k">const</span> <span class="f">trimClip</span> = (<span class="v">clipId</span>: <span class="t">string</span>, <span class="v">newStart</span>?: <span class="t">number</span>, <span class="v">newDuration</span>?: <span class="t">number</span>) => {
    timeline.value = coreTrimClip(timeline.value, clipId, newStart, newDuration)
  }

  <span class="k">return</span> {
    timeline: readonly(timeline),
    actions: {
      moveClip,
      trimClip
    }
  }
}</pre>
      </div>

      <div class="callout callout-info">
        <div class="callout-title">üí° Pattern Recognition</div>
        <p>Notice how both React and Vue adapters:</p>
        <ul>
          <li>Import the same core functions</li>
          <li>Wrap them in framework-specific state primitives</li>
          <li>Return the same API shape</li>
        </ul>
        <p>This means adding support for Svelte, Solid, or any framework is just writing a thin wrapper. The core logic never changes.</p>
      </div>
    </div>

    <hr>

    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
    <!-- CORE PACKAGE -->
    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->

    <div class="section" id="core-package">
      <div class="section-tag">Chapter 10</div>
      <h2>Core Package Implementation</h2>
      <p class="section-intro">
        The core package is where all the magic happens. Pure functions, zero dependencies, 100% tested. This is the foundation everything else builds on.
      </p>

      <h3>File Structure</h3>
      <div class="code-block">
        <div class="code-header">
          <span class="code-filename">packages/core/src/</span>
          <span class="code-lang">plaintext</span>
        </div>
        <pre>src/
‚îú‚îÄ‚îÄ types.ts          # All TypeScript interfaces
‚îú‚îÄ‚îÄ mutations.ts      # State-changing functions (moveClip, addTrack, etc.)
‚îú‚îÄ‚îÄ queries.ts        # Read-only functions (getActiveClips, etc.)
‚îú‚îÄ‚îÄ utils.ts          # Helper functions (timeToPixels, snapToGrid, etc.)
‚îú‚îÄ‚îÄ keyframes.ts      # Keyframe interpolation math
‚îî‚îÄ‚îÄ index.ts          # Public exports</pre>
      </div>

      <h3>Complete mutations.ts</h3>
      <div class="code-block">
        <div class="code-header">
          <span class="code-filename">packages/core/src/mutations.ts</span>
          <span class="code-lang">typescript</span>
        </div>
        <pre><span class="k">import</span> { <span class="t">Timeline</span>, <span class="t">Track</span>, <span class="t">Clip</span> } <span class="k">from</span> <span class="s">'./types'</span>

<span class="c">// ‚ïê‚ïê‚ïê CLIP MUTATIONS ‚ïê‚ïê‚ïê</span>

<span class="k">export function</span> <span class="f">moveClip</span>(
  <span class="v">timeline</span>: <span class="t">Timeline</span>,
  <span class="v">clipId</span>: <span class="t">string</span>,
  <span class="v">newStart</span>: <span class="t">number</span>,
  <span class="v">newTrackId</span>?: <span class="t">string</span>
): <span class="t">Timeline</span> {
  <span class="k">let</span> <span class="v">movedClip</span>: <span class="t">Clip</span> | <span class="k">null</span> = <span class="k">null</span>
  
  <span class="c">// Remove clip from old track</span>
  <span class="k">const</span> <span class="v">tracksWithoutClip</span> = timeline.tracks.map(<span class="v">track</span> => {
    <span class="k">const</span> <span class="v">clip</span> = track.clips.find(<span class="v">c</span> => c.id === clipId)
    <span class="k">if</span> (clip) movedClip = clip
    
    <span class="k">return</span> {
      ...track,
      clips: track.clips.filter(<span class="v">c</span> => c.id !== clipId)
    }
  })
  
  <span class="k">if</span> (!movedClip) <span class="k">return</span> timeline <span class="c">// Clip not found</span>
  
  <span class="c">// Add clip to new track with updated position</span>
  <span class="k">const</span> <span class="v">targetTrackId</span> = newTrackId || movedClip.trackId
  <span class="k">const</span> <span class="v">updatedClip</span> = { ...movedClip, start: newStart, trackId: targetTrackId }
  
  <span class="k">const</span> <span class="v">finalTracks</span> = tracksWithoutClip.map(<span class="v">track</span> =>
    track.id === targetTrackId
      ? { ...track, clips: [...track.clips, updatedClip].sort((<span class="v">a</span>, <span class="v">b</span>) => a.start - b.start) }
      : track
  )
  
  <span class="k">return</span> { ...timeline, tracks: finalTracks }
}

<span class="k">export function</span> <span class="f">trimClip</span>(
  <span class="v">timeline</span>: <span class="t">Timeline</span>,
  <span class="v">clipId</span>: <span class="t">string</span>,
  <span class="v">newStart</span>?: <span class="t">number</span>,
  <span class="v">newDuration</span>?: <span class="t">number</span>
): <span class="t">Timeline</span> {
  <span class="k">const</span> <span class="v">tracks</span> = timeline.tracks.map(<span class="v">track</span> => ({
    ...track,
    clips: track.clips.map(<span class="v">clip</span> =>
      clip.id === clipId
        ? {
            ...clip,
            ...(newStart !== <span class="k">undefined</span> && { start: newStart }),
            ...(newDuration !== <span class="k">undefined</span> && { duration: newDuration })
          }
        : clip
    )
  }))
  
  <span class="k">return</span> { ...timeline, tracks }
}

<span class="k">export function</span> <span class="f">splitClip</span>(
  <span class="v">timeline</span>: <span class="t">Timeline</span>,
  <span class="v">clipId</span>: <span class="t">string</span>,
  <span class="v">splitTime</span>: <span class="t">number</span>
): <span class="t">Timeline</span> {
  <span class="k">let</span> <span class="v">splitOccurred</span> = <span class="k">false</span>
  
  <span class="k">const</span> <span class="v">tracks</span> = timeline.tracks.map(<span class="v">track</span> => {
    <span class="k">const</span> <span class="v">clip</span> = track.clips.find(<span class="v">c</span> => c.id === clipId)
    <span class="k">if</span> (!clip) <span class="k">return</span> track
    
    <span class="c">// Check if split point is within clip bounds</span>
    <span class="k">if</span> (splitTime <= clip.start || splitTime >= clip.start + clip.duration) {
      <span class="k">return</span> track
    }
    
    splitOccurred = <span class="k">true</span>
    
    <span class="c">// Create two new clips</span>
    <span class="k">const</span> <span class="v">timeIntoClip</span> = splitTime - clip.start
    
    <span class="k">const</span> <span class="v">leftClip</span>: <span class="t">Clip</span> = {
      ...clip,
      id: `${clip.id}-left`,
      duration: timeIntoClip,
      trimEnd: clip.trimStart + timeIntoClip
    }
    
    <span class="k">const</span> <span class="v">rightClip</span>: <span class="t">Clip</span> = {
      ...clip,
      id: `${clip.id}-right`,
      start: splitTime,
      duration: clip.duration - timeIntoClip,
      trimStart: clip.trimStart + timeIntoClip
    }
    
    <span class="c">// Replace original clip with two new clips</span>
    <span class="k">const</span> <span class="v">newClips</span> = track.clips
      .filter(<span class="v">c</span> => c.id !== clipId)
      .concat([leftClip, rightClip])
      .sort((<span class="v">a</span>, <span class="v">b</span>) => a.start - b.start)
    
    <span class="k">return</span> { ...track, clips: newClips }
  })
  
  <span class="k">return</span> splitOccurred ? { ...timeline, tracks } : timeline
}

<span class="k">export function</span> <span class="f">deleteClip</span>(
  <span class="v">timeline</span>: <span class="t">Timeline</span>,
  <span class="v">clipId</span>: <span class="t">string</span>
): <span class="t">Timeline</span> {
  <span class="k">const</span> <span class="v">tracks</span> = timeline.tracks.map(<span class="v">track</span> => ({
    ...track,
    clips: track.clips.filter(<span class="v">c</span> => c.id !== clipId)
  }))
  
  <span class="k">return</span> { ...timeline, tracks }
}

<span class="c">// ‚ïê‚ïê‚ïê TRACK MUTATIONS ‚ïê‚ïê‚ïê</span>

<span class="k">export function</span> <span class="f">addTrack</span>(
  <span class="v">timeline</span>: <span class="t">Timeline</span>,
  <span class="v">type</span>: <span class="s">'video'</span> | <span class="s">'audio'</span> | <span class="s">'subtitle'</span> = <span class="s">'video'</span>
): <span class="t">Timeline</span> {
  <span class="k">const</span> <span class="v">newTrack</span>: <span class="t">Track</span> = {
    id: `track-${<span class="t">Date</span>.now()}-${<span class="t">Math</span>.random().toString(<span class="n">36</span>).substr(<span class="n">2</span>, <span class="n">9</span>)}`,
    name: `${type.charAt(<span class="n">0</span>).toUpperCase() + type.slice(<span class="n">1</span>)} Track ${timeline.tracks.length + <span class="n">1</span>}`,
    type,
    clips: [],
    height: <span class="n">64</span>,
    locked: <span class="k">false</span>,
    visible: <span class="k">true</span>,
    muted: <span class="k">false</span>,
    order: timeline.tracks.length
  }
  
  <span class="k">return</span> {
    ...timeline,
    tracks: [...timeline.tracks, newTrack]
  }
}

<span class="k">export function</span> <span class="f">deleteTrack</span>(
  <span class="v">timeline</span>: <span class="t">Timeline</span>,
  <span class="v">trackId</span>: <span class="t">string</span>
): <span class="t">Timeline</span> {
  <span class="k">const</span> <span class="v">tracks</span> = timeline.tracks
    .filter(<span class="v">t</span> => t.id !== trackId)
    .map((<span class="v">track</span>, <span class="v">index</span>) => ({ ...track, order: index }))
  
  <span class="k">return</span> { ...timeline, tracks }
}

<span class="k">export function</span> <span class="f">reorderTracks</span>(
  <span class="v">timeline</span>: <span class="t">Timeline</span>,
  <span class="v">trackId</span>: <span class="t">string</span>,
  <span class="v">newOrder</span>: <span class="t">number</span>
): <span class="t">Timeline</span> {
  <span class="k">const</span> <span class="v">trackIndex</span> = timeline.tracks.findIndex(<span class="v">t</span> => t.id === trackId)
  <span class="k">if</span> (trackIndex === -<span class="n">1</span>) <span class="k">return</span> timeline
  
  <span class="k">const</span> <span class="v">tracks</span> = [...timeline.tracks]
  <span class="k">const</span> [<span class="v">movedTrack</span>] = tracks.splice(trackIndex, <span class="n">1</span>)
  tracks.splice(newOrder, <span class="n">0</span>, movedTrack)
  
  <span class="c">// Update order values</span>
  <span class="k">const</span> <span class="v">reorderedTracks</span> = tracks.map((<span class="v">track</span>, <span class="v">index</span>) => ({
    ...track,
    order: index
  }))
  
  <span class="k">return</span> { ...timeline, tracks: reorderedTracks }
}</pre>
      </div>

      <h3>Complete queries.ts</h3>
      <div class="code-block">
        <div class="code-header">
          <span class="code-filename">packages/core/src/queries.ts</span>
          <span class="code-lang">typescript</span>
        </div>
        <pre><span class="k">import</span> { <span class="t">Timeline</span>, <span class="t">Clip</span>, <span class="t">Track</span> } <span class="k">from</span> <span class="s">'./types'</span>

<span class="c">/**
 * Get all clips that are active (playing) at a specific time
 */</span>
<span class="k">export function</span> <span class="f">getActiveClipsAtTime</span>(
  <span class="v">timeline</span>: <span class="t">Timeline</span>,
  <span class="v">time</span>: <span class="t">number</span>
): <span class="t">Clip</span>[] {
  <span class="k">const</span> <span class="v">activeClips</span>: <span class="t">Clip</span>[] = []
  
  <span class="k">for</span> (<span class="k">const</span> <span class="v">track</span> <span class="k">of</span> timeline.tracks) {
    <span class="k">for</span> (<span class="k">const</span> <span class="v">clip</span> <span class="k">of</span> track.clips) {
      <span class="k">const</span> <span class="v">clipEnd</span> = clip.start + clip.duration
      <span class="k">if</span> (clip.start <= time && time < clipEnd) {
        activeClips.push(clip)
      }
    }
  }
  
  <span class="c">// Sort by track order (bottom to top)</span>
  <span class="k">return</span> activeClips.sort((<span class="v">a</span>, <span class="v">b</span>) => {
    <span class="k">const</span> <span class="v">trackA</span> = timeline.tracks.find(<span class="v">t</span> => t.id === a.trackId)
    <span class="k">const</span> <span class="v">trackB</span> = timeline.tracks.find(<span class="v">t</span> => t.id === b.trackId)
    <span class="k">return</span> (trackA?.order ?? <span class="n">0</span>) - (trackB?.order ?? <span class="n">0</span>)
  })
}

<span class="c">/**
 * Get the next edit point (clip boundary) after current time
 */</span>
<span class="k">export function</span> <span class="f">getNextEditPoint</span>(
  <span class="v">timeline</span>: <span class="t">Timeline</span>,
  <span class="v">currentTime</span>: <span class="t">number</span>
): <span class="t">number</span> | <span class="k">null</span> {
  <span class="k">let</span> <span class="v">nextPoint</span> = <span class="t">Infinity</span>
  
  <span class="k">for</span> (<span class="k">const</span> <span class="v">track</span> <span class="k">of</span> timeline.tracks) {
    <span class="k">for</span> (<span class="k">const</span> <span class="v">clip</span> <span class="k">of</span> track.clips) {
      <span class="c">// Check clip start</span>
      <span class="k">if</span> (clip.start > currentTime && clip.start < nextPoint) {
        nextPoint = clip.start
      }
      <span class="c">// Check clip end</span>
      <span class="k">const</span> <span class="v">clipEnd</span> = clip.start + clip.duration
      <span class="k">if</span> (clipEnd > currentTime && clipEnd < nextPoint) {
        nextPoint = clipEnd
      }
    }
  }
  
  <span class="k">return</span> nextPoint === <span class="t">Infinity</span> ? <span class="k">null</span> : nextPoint
}

<span class="c">/**
 * Get the previous edit point before current time
 */</span>
<span class="k">export function</span> <span class="f">getPreviousEditPoint</span>(
  <span class="v">timeline</span>: <span class="t">Timeline</span>,
  <span class="v">currentTime</span>: <span class="t">number</span>
): <span class="t">number</span> | <span class="k">null</span> {
  <span class="k">let</span> <span class="v">prevPoint</span> = -<span class="t">Infinity</span>
  
  <span class="k">for</span> (<span class="k">const</span> <span class="v">track</span> <span class="k">of</span> timeline.tracks) {
    <span class="k">for</span> (<span class="k">const</span> <span class="v">clip</span> <span class="k">of</span> track.clips) {
      <span class="k">if</span> (clip.start < currentTime && clip.start > prevPoint) {
        prevPoint = clip.start
      }
      <span class="k">const</span> <span class="v">clipEnd</span> = clip.start + clip.duration
      <span class="k">if</span> (clipEnd < currentTime && clipEnd > prevPoint) {
        prevPoint = clipEnd
      }
    }
  }
  
  <span class="k">return</span> prevPoint === -<span class="t">Infinity</span> ? <span class="k">null</span> : prevPoint
}

<span class="c">/**
 * Check if two clips overlap in time
 */</span>
<span class="k">export function</span> <span class="f">clipsOverlap</span>(<span class="v">clip1</span>: <span class="t">Clip</span>, <span class="v">clip2</span>: <span class="t">Clip</span>): <span class="t">boolean</span> {
  <span class="c">// Only clips on same track can overlap</span>
  <span class="k">if</span> (clip1.trackId !== clip2.trackId) <span class="k">return</span> <span class="k">false</span>
  
  <span class="k">const</span> <span class="v">end1</span> = clip1.start + clip1.duration
  <span class="k">const</span> <span class="v">end2</span> = clip2.start + clip2.duration
  
  <span class="k">return</span> clip1.start < end2 && clip2.start < end1
}

<span class="c">/**
 * Get all clips on a specific track
 */</span>
<span class="k">export function</span> <span class="f">getClipsByTrack</span>(
  <span class="v">timeline</span>: <span class="t">Timeline</span>,
  <span class="v">trackId</span>: <span class="t">string</span>
): <span class="t">Clip</span>[] {
  <span class="k">const</span> <span class="v">track</span> = timeline.tracks.find(<span class="v">t</span> => t.id === trackId)
  <span class="k">return</span> track ? track.clips : []
}</pre>
      </div>

      <div class="callout callout-success">
        <div class="callout-title">‚úÖ Core Package Principles</div>
        <ul>
          <li><strong>Pure functions only</strong> ‚Äî No side effects, always return new objects</li>
          <li><strong>Comprehensive JSDoc</strong> ‚Äî Every public function documented</li>
          <li><strong>Defensive programming</strong> ‚Äî Check for null/undefined, return original if invalid</li>
          <li><strong>100% test coverage</strong> ‚Äî Every function has unit tests</li>
        </ul>
      </div>
    </div>

    <hr>

    <!-- Continue with remaining sections (React, Components, CLI, Performance, Testing, Documentation, Pitfalls, Roadmap) -->

    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
    <!-- REACT PACKAGE -->
    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->

    <div class="section" id="react-package">
      <div class="section-tag">Chapter 11</div>
      <h2>React Package Deep Dive</h2>
      <p class="section-intro">
        The React adapter package brings core timeline functionality into React applications with hooks, context, and optimal re-rendering strategies.
      </p>

      <h3>useDrag Hook (Complex Interaction)</h3>
      <p>Dragging clips is the most complex interaction in a timeline. Here's a production-ready implementation:</p>

      <div class="code-block">
        <div class="code-header">
          <span class="code-filename">packages/react/src/hooks/useDrag.ts</span>
          <span class="code-lang">typescript</span>
        </div>
        <pre><span class="k">import</span> { useState, useCallback, useRef, useEffect } <span class="k">from</span> <span class="s">'react'</span>

<span class="k">interface</span> <span class="t">DragState</span> {
  isDragging: <span class="t">boolean</span>
  clipId: <span class="t">string</span> | <span class="k">null</span>
  startX: <span class="t">number</span>
  startY: <span class="t">number</span>
  currentX: <span class="t">number</span>
  currentY: <span class="t">number</span>
  originalStart: <span class="t">number</span>
  originalTrackId: <span class="t">string</span>
}

<span class="k">export function</span> <span class="f">useDrag</span>(<span class="v">pixelsPerSecond</span>: <span class="t">number</span> = <span class="n">100</span>) {
  <span class="k">const</span> [<span class="v">dragState</span>, <span class="v">setDragState</span>] = useState&lt;<span class="t">DragState</span>&gt;({
    isDragging: <span class="k">false</span>,
    clipId: <span class="k">null</span>,
    startX: <span class="n">0</span>,
    startY: <span class="n">0</span>,
    currentX: <span class="n">0</span>,
    currentY: <span class="n">0</span>,
    originalStart: <span class="n">0</span>,
    originalTrackId: <span class="s">''</span>
  })

  <span class="k">const</span> <span class="v">dragRef</span> = useRef(<span class="k">null</span>)

  <span class="k">const</span> <span class="f">startDrag</span> = useCallback((
    <span class="v">clipId</span>: <span class="t">string</span>,
    <span class="v">mouseX</span>: <span class="t">number</span>,
    <span class="v">mouseY</span>: <span class="t">number</span>,
    <span class="v">clipStart</span>: <span class="t">number</span>,
    <span class="v">trackId</span>: <span class="t">string</span>
  ) => {
    setDragState({
      isDragging: <span class="k">true</span>,
      clipId,
      startX: mouseX,
      startY: mouseY,
      currentX: mouseX,
      currentY: mouseY,
      originalStart: clipStart,
      originalTrackId: trackId
    })
  }, [])

  <span class="k">const</span> <span class="f">stopDrag</span> = useCallback(() => {
    setDragState(<span class="v">prev</span> => ({ ...prev, isDragging: <span class="k">false</span>, clipId: <span class="k">null</span> }))
  }, [])

  <span class="c">// Mouse move handler</span>
  useEffect(() => {
    <span class="k">if</span> (!dragState.isDragging) <span class="k">return</span>

    <span class="k">const</span> <span class="f">handleMouseMove</span> = (<span class="v">e</span>: <span class="t">MouseEvent</span>) => {
      setDragState(<span class="v">prev</span> => ({
        ...prev,
        currentX: e.clientX,
        currentY: e.clientY
      }))
    }

    <span class="k">const</span> <span class="f">handleMouseUp</span> = () => {
      stopDrag()
    }

    window.addEventListener(<span class="s">'mousemove'</span>, handleMouseMove)
    window.addEventListener(<span class="s">'mouseup'</span>, handleMouseUp)

    <span class="k">return</span> () => {
      window.removeEventListener(<span class="s">'mousemove'</span>, handleMouseMove)
      window.removeEventListener(<span class="s">'mouseup'</span>, handleMouseUp)
    }
  }, [dragState.isDragging, stopDrag])

  <span class="c">// Calculate new time based on drag distance</span>
  <span class="k">const</span> <span class="v">deltaX</span> = dragState.currentX - dragState.startX
  <span class="k">const</span> <span class="v">deltaTime</span> = deltaX / pixelsPerSecond
  <span class="k">const</span> <span class="v">newStart</span> = <span class="t">Math</span>.max(<span class="n">0</span>, dragState.originalStart + deltaTime)

  <span class="k">return</span> {
    dragState,
    startDrag,
    stopDrag,
    newStart,
    deltaX,
    deltaY: dragState.currentY - dragState.startY
  }
}</pre>
      </div>

      <h3>useZoom Hook</h3>
      <div class="code-block">
        <div class="code-header">
          <span class="code-filename">packages/react/src/hooks/useZoom.ts</span>
          <span class="code-lang">typescript</span>
        </div>
        <pre><span class="k">import</span> { useState, useCallback } <span class="k">from</span> <span class="s">'react'</span>

<span class="k">export function</span> <span class="f">useZoom</span>(
  <span class="v">initialZoom</span> = <span class="n">100</span>,
  <span class="v">minZoom</span> = <span class="n">10</span>,
  <span class="v">maxZoom</span> = <span class="n">1000</span>
) {
  <span class="k">const</span> [<span class="v">zoom</span>, <span class="v">setZoom</span>] = useState(<span class="v">initialZoom</span>)
  <span class="k">const</span> [<span class="v">scrollLeft</span>, <span class="v">setScrollLeft</span>] = useState(<span class="n">0</span>)

  <span class="k">const</span> <span class="f">zoomIn</span> = useCallback((<span class="v">factor</span> = <span class="n">1.2</span>) => {
    setZoom(<span class="v">z</span> => <span class="t">Math</span>.min(maxZoom, z * factor))
  }, [maxZoom])

  <span class="k">const</span> <span class="f">zoomOut</span> = useCallback((<span class="v">factor</span> = <span class="n">1.2</span>) => {
    setZoom(<span class="v">z</span> => <span class="t">Math</span>.max(minZoom, z / factor))
  }, [minZoom])

  <span class="k">const</span> <span class="f">zoomTo</span> = useCallback((<span class="v">newZoom</span>: <span class="t">number</span>) => {
    setZoom(<span class="t">Math</span>.max(minZoom, <span class="t">Math</span>.min(maxZoom, newZoom)))
  }, [minZoom, maxZoom])

  <span class="k">const</span> <span class="f">fitToView</span> = useCallback((<span class="v">timelineDuration</span>: <span class="t">number</span>, <span class="v">containerWidth</span>: <span class="t">number</span>) => {
    <span class="k">const</span> <span class="v">newZoom</span> = containerWidth / timelineDuration
    zoomTo(newZoom)
    setScrollLeft(<span class="n">0</span>)
  }, [zoomTo])

  <span class="k">return</span> {
    zoom,
    scrollLeft,
    setScrollLeft,
    zoomIn,
    zoomOut,
    zoomTo,
    fitToView,
    pixelsPerSecond: zoom
  }
}</pre>
      </div>

      <h3>TimelineContext (Advanced)</h3>
      <p>For complex apps, provide timeline state through context:</p>

      <div class="code-block">
        <div class="code-header">
          <span class="code-filename">packages/react/src/context/TimelineContext.tsx</span>
          <span class="code-lang">typescript</span>
        </div>
        <pre><span class="k">import</span> { createContext, useContext, <span class="t">ReactNode</span> } <span class="k">from</span> <span class="s">'react'</span>
<span class="k">import</span> { <span class="t">Timeline</span> } <span class="k">from</span> <span class="s">'@timeline/core'</span>
<span class="k">import</span> { useTimeline } <span class="k">from</span> <span class="s">'../hooks/useTimeline'</span>
<span class="k">import</span> { useHistory } <span class="k">from</span> <span class="s">'../hooks/useHistory'</span>
<span class="k">import</span> { usePlayback } <span class="k">from</span> <span class="s">'../hooks/usePlayback'</span>
<span class="k">import</span> { useZoom } <span class="k">from</span> <span class="s">'../hooks/useZoom'</span>

<span class="k">interface</span> <span class="t">TimelineContextValue</span> {
  timeline: <span class="t">Timeline</span>
  actions: <span class="t">ReturnType</span>&lt;<span class="k">typeof</span> useTimeline&gt;[<span class="s">'actions'</span>]
  history: <span class="t">ReturnType</span>&lt;<span class="k">typeof</span> useHistory&gt;
  playback: <span class="t">ReturnType</span>&lt;<span class="k">typeof</span> usePlayback&gt;
  zoom: <span class="t">ReturnType</span>&lt;<span class="k">typeof</span> useZoom&gt;
}

<span class="k">const</span> <span class="v">TimelineContext</span> = createContext&lt;<span class="t">TimelineContextValue</span> | <span class="k">null</span>&gt;(<span class="k">null</span>)

<span class="k">export function</span> <span class="f">TimelineProvider</span>({
  <span class="v">children</span>,
  <span class="v">initialTimeline</span>
}: {
  <span class="v">children</span>: <span class="t">ReactNode</span>
  <span class="v">initialTimeline</span>: <span class="t">Timeline</span>
}) {
  <span class="k">const</span> { timeline, actions } = useTimeline(initialTimeline)
  <span class="k">const</span> <span class="v">history</span> = useHistory(timeline)
  <span class="k">const</span> <span class="v">playback</span> = usePlayback(timeline.frameRate)
  <span class="k">const</span> <span class="v">zoom</span> = useZoom()

  <span class="k">return</span> (
    <span class="p">&lt;</span><span class="t">TimelineContext.Provider</span>
      <span class="v">value</span>={{ timeline, actions, history, playback, zoom }}
    <span class="p">&gt;</span>
      {children}
    <span class="p">&lt;/</span><span class="t">TimelineContext.Provider</span><span class="p">&gt;</span>
  )
}

<span class="k">export function</span> <span class="f">useTimelineContext</span>() {
  <span class="k">const</span> <span class="v">context</span> = useContext(<span class="v">TimelineContext</span>)
  <span class="k">if</span> (!context) {
    <span class="k">throw new</span> <span class="t">Error</span>(<span class="s">'useTimelineContext must be used within TimelineProvider'</span>)
  }
  <span class="k">return</span> context
}</pre>
      </div>
    </div>

    <hr>

    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
    <!-- COMPONENTS -->
    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->

    <div class="section" id="components">
      <div class="section-tag">Chapter 12</div>
      <h2>UI Components</h2>
      <p class="section-intro">
        These are the actual timeline components users install via CLI. They're unstyled primitives that users fully own and customize.
      </p>

      <h3>Timeline Component (Root)</h3>
      <div class="code-block">
        <div class="code-header">
          <span class="code-filename">registry/components/timeline.tsx</span>
          <span class="code-lang">tsx</span>
        </div>
        <pre><span class="k">import</span> { useTimelineContext } <span class="k">from</span> <span class="s">'@timeline/react'</span>
<span class="k">import</span> { Track } <span class="k">from</span> <span class="s">'./track'</span>
<span class="k">import</span> { Playhead } <span class="k">from</span> <span class="s">'./playhead'</span>
<span class="k">import</span> { TimeRuler } <span class="k">from</span> <span class="s">'./ruler'</span>

<span class="k">export function</span> <span class="f">Timeline</span>() {
  <span class="k">const</span> { timeline, zoom } = useTimelineContext()
  
  <span class="k">return</span> (
    <span class="p">&lt;</span><span class="t">div</span> <span class="v">className</span>=<span class="s">"timeline-container"</span><span class="p">&gt;</span>
      <span class="c">{/* Time ruler at top */}</span>
      <span class="p">&lt;</span><span class="t">TimeRuler</span> 
        <span class="v">duration</span>={timeline.duration}
        <span class="v">zoom</span>={zoom.pixelsPerSecond}
      <span class="p">/&gt;</span>
      
      <span class="c">{/* Scrollable tracks area */}</span>
      <span class="p">&lt;</span><span class="t">div</span> <span class="v">className</span>=<span class="s">"timeline-tracks"</span><span class="p">&gt;</span>
        {timeline.tracks
          .sort((<span class="v">a</span>, <span class="v">b</span>) => a.order - b.order)
          .map(<span class="v">track</span> => (
            <span class="p">&lt;</span><span class="t">Track</span> <span class="v">key</span>={track.id} <span class="v">track</span>={track} <span class="p">/&gt;</span>
          ))}
      <span class="p">&lt;/</span><span class="t">div</span><span class="p">&gt;</span>
      
      <span class="c">{/* Playhead overlay */}</span>
      <span class="p">&lt;</span><span class="t">Playhead</span> <span class="p">/&gt;</span>
    <span class="p">&lt;/</span><span class="t">div</span><span class="p">&gt;</span>
  )
}</pre>
      </div>

      <h3>Clip Component (Draggable)</h3>
      <div class="code-block">
        <div class="code-header">
          <span class="code-filename">registry/components/clip.tsx</span>
          <span class="code-lang">tsx</span>
        </div>
        <pre><span class="k">import</span> { useTimelineContext } <span class="k">from</span> <span class="s">'@timeline/react'</span>
<span class="k">import</span> { useDrag } <span class="k">from</span> <span class="s">'@timeline/react'</span>
<span class="k">import</span> { <span class="t">Clip</span> <span class="k">as</span> <span class="t">ClipType</span> } <span class="k">from</span> <span class="s">'@timeline/core'</span>

<span class="k">interface</span> <span class="t">ClipProps</span> {
  clip: <span class="t">ClipType</span>
}

<span class="k">export function</span> <span class="f">Clip</span>({ <span class="v">clip</span> }: <span class="t">ClipProps</span>) {
  <span class="k">const</span> { actions, zoom } = useTimelineContext()
  <span class="k">const</span> <span class="v">drag</span> = useDrag(zoom.pixelsPerSecond)
  
  <span class="k">const</span> <span class="f">handleMouseDown</span> = (<span class="v">e</span>: <span class="t">React</span>.<span class="t">MouseEvent</span>) => {
    e.preventDefault()
    drag.startDrag(clip.id, e.clientX, e.clientY, clip.start, clip.trackId)
  }
  
  <span class="c">// Calculate position and width</span>
  <span class="k">const</span> <span class="v">left</span> = clip.start * zoom.pixelsPerSecond
  <span class="k">const</span> <span class="v">width</span> = clip.duration * zoom.pixelsPerSecond
  
  <span class="c">// If dragging this clip, use new position</span>
  <span class="k">const</span> <span class="v">finalLeft</span> = drag.dragState.clipId === clip.id && drag.dragState.isDragging
    ? drag.newStart * zoom.pixelsPerSecond
    : left
  
  <span class="k">return</span> (
    <span class="p">&lt;</span><span class="t">div</span>
      <span class="v">className</span>=<span class="s">"clip"</span>
      <span class="v">style</span>={{
        position: <span class="s">'absolute'</span>,
        left: `${finalLeft}px`,
        width: `${width}px`,
        height: <span class="s">'100%'</span>,
        backgroundColor: clip.color || <span class="s">'#3b82f6'</span>,
        cursor: drag.dragState.isDragging ? <span class="s">'grabbing'</span> : <span class="s">'grab'</span>
      }}
      <span class="v">onMouseDown</span>={handleMouseDown}
    <span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="t">div</span> <span class="v">className</span>=<span class="s">"clip-name"</span><span class="p">&gt;</span>{clip.name}<span class="p">&lt;/</span><span class="t">div</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="t">div</span><span class="p">&gt;</span>
  )
}</pre>
      </div>

      <h3>Registry Structure</h3>
      <div class="code-block">
        <div class="code-header">
          <span class="code-filename">registry/registry.json</span>
          <span class="code-lang">json</span>
        </div>
        <pre>{
  <span class="s">"components"</span>: [
    {
      <span class="s">"name"</span>: <span class="s">"timeline"</span>,
      <span class="s">"type"</span>: <span class="s">"component"</span>,
      <span class="s">"files"</span>: [<span class="s">"components/timeline.tsx"</span>],
      <span class="s">"dependencies"</span>: [<span class="s">"@timeline/react"</span>],
      <span class="s">"registryDependencies"</span>: [<span class="s">"track"</span>, <span class="s">"playhead"</span>, <span class="s">"ruler"</span>]
    },
    {
      <span class="s">"name"</span>: <span class="s">"track"</span>,
      <span class="s">"type"</span>: <span class="s">"component"</span>,
      <span class="s">"files"</span>: [<span class="s">"components/track.tsx"</span>],
      <span class="s">"dependencies"</span>: [<span class="s">"@timeline/react"</span>],
      <span class="s">"registryDependencies"</span>: [<span class="s">"clip"</span>]
    },
    {
      <span class="s">"name"</span>: <span class="s">"clip"</span>,
      <span class="s">"type"</span>: <span class="s">"component"</span>,
      <span class="s">"files"</span>: [<span class="s">"components/clip.tsx"</span>],
      <span class="s">"dependencies"</span>: [<span class="s">"@timeline/react"</span>, <span class="s">"@timeline/core"</span>]
    }
  ]
}</pre>
      </div>
    </div>

    <hr>

    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
    <!-- CLI -->
    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->

    <div class="section" id="cli">
      <div class="section-tag">Chapter 13</div>
      <h2>CLI Tool</h2>
      <p class="section-intro">
        The CLI is what makes your library feel like magic. One command and components appear in the user's codebase.
      </p>

      <h3>CLI Commands</h3>

      <h4>timeline init</h4>
      <div class="code-block">
        <div class="code-header">
          <span class="code-filename">packages/cli/src/commands/init.ts</span>
          <span class="code-lang">typescript</span>
        </div>
        <pre><span class="k">import</span> * <span class="k">as</span> fs <span class="k">from</span> <span class="s">'fs-extra'</span>
<span class="k">import</span> * <span class="k">as</span> path <span class="k">from</span> <span class="s">'path'</span>
<span class="k">import</span> prompts <span class="k">from</span> <span class="s">'prompts'</span>
<span class="k">import</span> chalk <span class="k">from</span> <span class="s">'chalk'</span>
<span class="k">import</span> ora <span class="k">from</span> <span class="s">'ora'</span>
<span class="k">import</span> { execa } <span class="k">from</span> <span class="s">'execa'</span>

<span class="k">export async function</span> <span class="f">init</span>() {
  console.log(chalk.bold(<span class="s">'\nTimeline Library Setup\n'</span>))
  
  <span class="c">// Detect framework</span>
  <span class="k">const</span> <span class="v">framework</span> = <span class="k">await</span> detectFramework()
  
  <span class="c">// Ask user for configuration</span>
  <span class="k">const</span> <span class="v">config</span> = <span class="k">await</span> prompts([
    {
      type: <span class="s">'select'</span>,
      name: <span class="s">'framework'</span>,
      message: <span class="s">'Which framework are you using?'</span>,
      choices: [
        { title: <span class="s">'React'</span>, value: <span class="s">'react'</span> },
        { title: <span class="s">'Vue'</span>, value: <span class="s">'vue'</span> },
        { title: <span class="s">'Svelte'</span>, value: <span class="s">'svelte'</span> }
      ],
      initial: framework === <span class="s">'react'</span> ? <span class="n">0</span> : <span class="n">1</span>
    },
    {
      type: <span class="s">'text'</span>,
      name: <span class="s">'componentsPath'</span>,
      message: <span class="s">'Where should we install components?'</span>,
      initial: <span class="s">'src/components/timeline'</span>
    }
  ])
  
  <span class="c">// Install dependencies</span>
  <span class="k">const</span> <span class="v">spinner</span> = ora(<span class="s">'Installing dependencies...'</span>).start()
  
  <span class="k">try</span> {
    <span class="k">await</span> execa(<span class="s">'npm'</span>, [
      <span class="s">'install'</span>,
      <span class="s">'@timeline/core'</span>,
      `@timeline/${config.framework}`
    ])
    
    spinner.succeed(<span class="s">'Dependencies installed'</span>)
  } <span class="k">catch</span> (<span class="v">error</span>) {
    spinner.fail(<span class="s">'Failed to install dependencies'</span>)
    <span class="k">throw</span> error
  }
  
  <span class="c">// Create config file</span>
  <span class="k">const</span> <span class="v">configPath</span> = path.join(process.cwd(), <span class="s">'timeline.config.json'</span>)
  <span class="k">await</span> fs.writeJson(configPath, config, { spaces: <span class="n">2</span> })
  
  console.log(chalk.green(<span class="s">'\n‚úì Timeline library initialized!\n'</span>))
  console.log(<span class="s">'Next steps:'</span>)
  console.log(chalk.cyan(<span class="s">'  timeline add timeline'</span>) + <span class="s">' - Install timeline component'</span>)
}

<span class="k">async function</span> <span class="f">detectFramework</span>(): <span class="t">Promise</span>&lt;<span class="t">string</span>&gt; {
  <span class="k">const</span> <span class="v">packageJsonPath</span> = path.join(process.cwd(), <span class="s">'package.json'</span>)
  
  <span class="k">if</span> (<span class="k">await</span> fs.pathExists(packageJsonPath)) {
    <span class="k">const</span> <span class="v">packageJson</span> = <span class="k">await</span> fs.readJson(packageJsonPath)
    <span class="k">const</span> <span class="v">deps</span> = { ...packageJson.dependencies, ...packageJson.devDependencies }
    
    <span class="k">if</span> (deps.react) <span class="k">return</span> <span class="s">'react'</span>
    <span class="k">if</span> (deps.vue) <span class="k">return</span> <span class="s">'vue'</span>
    <span class="k">if</span> (deps.svelte) <span class="k">return</span> <span class="s">'svelte'</span>
  }
  
  <span class="k">return</span> <span class="s">'react'</span> <span class="c">// default</span>
}</pre>
      </div>

      <h4>timeline add [component]</h4>
      <div class="code-block">
        <div class="code-header">
          <span class="code-filename">packages/cli/src/commands/add.ts</span>
          <span class="code-lang">typescript</span>
        </div>
        <pre><span class="k">import</span> * <span class="k">as</span> fs <span class="k">from</span> <span class="s">'fs-extra'</span>
<span class="k">import</span> * <span class="k">as</span> path <span class="k">from</span> <span class="s">'path'</span>
<span class="k">import</span> chalk <span class="k">from</span> <span class="s">'chalk'</span>
<span class="k">import</span> ora <span class="k">from</span> <span class="s">'ora'</span>

<span class="k">interface</span> <span class="t">Component</span> {
  name: <span class="t">string</span>
  files: <span class="t">string</span>[]
  dependencies: <span class="t">string</span>[]
  registryDependencies: <span class="t">string</span>[]
}

<span class="k">export async function</span> <span class="f">add</span>(<span class="v">componentName</span>: <span class="t">string</span>) {
  <span class="c">// Load config</span>
  <span class="k">const</span> <span class="v">config</span> = <span class="k">await</span> loadConfig()
  
  <span class="c">// Fetch registry</span>
  <span class="k">const</span> <span class="v">spinner</span> = ora(<span class="s">'Fetching component registry...'</span>).start()
  <span class="k">const</span> <span class="v">registry</span> = <span class="k">await</span> fetchRegistry()
  
  <span class="c">// Find component</span>
  <span class="k">const</span> <span class="v">component</span> = registry.components.find(
    (<span class="v">c</span>: <span class="t">Component</span>) => c.name === componentName
  )
  
  <span class="k">if</span> (!component) {
    spinner.fail(<span class="s">`Component "${componentName}" not found`</span>)
    <span class="k">return</span>
  }
  
  spinner.text = <span class="s">`Installing ${componentName}...`</span>
  
  <span class="c">// Resolve all dependencies (recursively)</span>
  <span class="k">const</span> <span class="v">allComponents</span> = resolveDependencies(component, registry)
  
  <span class="c">// Copy component files</span>
  <span class="k">for</span> (<span class="k">const</span> <span class="v">comp</span> <span class="k">of</span> allComponents) {
    <span class="k">for</span> (<span class="k">const</span> <span class="v">file</span> <span class="k">of</span> comp.files) {
      <span class="k">const</span> <span class="v">source</span> = <span class="k">await</span> fetchComponentFile(file)
      <span class="k">const</span> <span class="v">target</span> = path.join(
        process.cwd(),
        config.componentsPath,
        path.basename(file)
      )
      
      <span class="k">await</span> fs.ensureDir(path.dirname(target))
      <span class="k">await</span> fs.writeFile(target, source)
    }
  }
  
  spinner.succeed(<span class="s">`Installed ${componentName} and ${allComponents.length - <span class="n">1</span>} dependencies`</span>)
  
  console.log(<span class="s">'\n'</span> + chalk.green(<span class="s">'Files created:'</span>))
  allComponents.forEach(<span class="v">c</span> => {
    console.log(chalk.cyan(<span class="s">`  - ${c.name}.tsx`</span>))
  })
}

<span class="k">function</span> <span class="f">resolveDependencies</span>(
  <span class="v">component</span>: <span class="t">Component</span>,
  <span class="v">registry</span>: <span class="t">any</span>
): <span class="t">Component</span>[] {
  <span class="k">const</span> <span class="v">result</span>: <span class="t">Component</span>[] = [component]
  <span class="k">const</span> <span class="v">visited</span> = <span class="k">new</span> <span class="t">Set</span>&lt;<span class="t">string</span>&gt;([component.name])
  
  <span class="k">const</span> <span class="f">resolve</span> = (<span class="v">comp</span>: <span class="t">Component</span>) => {
    <span class="k">for</span> (<span class="k">const</span> <span class="v">depName</span> <span class="k">of</span> comp.registryDependencies || []) {
      <span class="k">if</span> (visited.has(depName)) <span class="k">continue</span>
      
      <span class="k">const</span> <span class="v">dep</span> = registry.components.find((<span class="v">c</span>: <span class="t">Component</span>) => c.name === depName)
      <span class="k">if</span> (dep) {
        visited.add(depName)
        result.push(dep)
        resolve(dep)
      }
    }
  }
  
  resolve(component)
  <span class="k">return</span> result
}</pre>
      </div>

      <h3>Usage Example</h3>
      <div class="code-block">
        <div class="code-header">
          <span class="code-filename">Terminal</span>
          <span class="code-lang">bash</span>
        </div>
        <pre><span class="c"># Initialize timeline library in your project</span>
npx timeline-cli init

<span class="c"># Install timeline component (pulls in track, clip, playhead, ruler)</span>
npx timeline-cli add timeline

<span class="c"># Files are now in your src/components/timeline/</span>
<span class="c"># You own them - modify as needed!</span></pre>
      </div>
    </div>

    <hr>

    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
    <!-- PERFORMANCE -->
    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->

    <div class="section" id="performance">
      <div class="section-tag">Chapter 14</div>
      <h2>Performance Optimization</h2>
      <p class="section-intro">
        A timeline with 1000+ clips must feel instant. Here's how to achieve that.
      </p>

      <h3>Critical Optimizations</h3>

      <h4>1. Virtualization</h4>
      <p>Only render visible clips/tracks:</p>

      <div class="code-block">
        <div class="code-header">
          <span class="code-filename">Using @tanstack/react-virtual</span>
          <span class="code-lang">tsx</span>
        </div>
        <pre><span class="k">import</span> { useVirtualizer } <span class="k">from</span> <span class="s">'@tanstack/react-virtual'</span>

<span class="k">function</span> <span class="f">Timeline</span>() {
  <span class="k">const</span> <span class="v">parentRef</span> = useRef&lt;<span class="t">HTMLDivElement</span>&gt;(<span class="k">null</span>)
  <span class="k">const</span> { timeline } = useTimelineContext()
  
  <span class="c">// Virtualize tracks</span>
  <span class="k">const</span> <span class="v">rowVirtualizer</span> = useVirtualizer({
    count: timeline.tracks.length,
    getScrollElement: () => parentRef.current,
    estimateSize: () => <span class="n">64</span>, <span class="c">// track height</span>
    overscan: <span class="n">2</span>
  })
  
  <span class="k">return</span> (
    <span class="p">&lt;</span><span class="t">div</span> <span class="v">ref</span>={parentRef} <span class="v">style</span>={{ height: <span class="s">'400px'</span>, overflow: <span class="s">'auto'</span> }}<span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="t">div</span> <span class="v">style</span>={{ height: rowVirtualizer.getTotalSize() }}<span class="p">&gt;</span>
        {rowVirtualizer.getVirtualItems().map(<span class="v">virtualRow</span> => (
          <span class="p">&lt;</span><span class="t">Track</span>
            <span class="v">key</span>={virtualRow.key}
            <span class="v">track</span>={timeline.tracks[virtualRow.index]}
            <span class="v">style</span>={{
              position: <span class="s">'absolute'</span>,
              top: <span class="n">0</span>,
              left: <span class="n">0</span>,
              width: <span class="s">'100%'</span>,
              transform: `translateY(${virtualRow.start}px)`
            }}
          <span class="p">/&gt;</span>
        ))}
      <span class="p">&lt;/</span><span class="t">div</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="t">div</span><span class="p">&gt;</span>
  )
}</pre>
      </div>

      <h4>2. Memoization</h4>
      <div class="code-block">
        <div class="code-header">
          <span class="code-filename">Prevent unnecessary recalculations</span>
          <span class="code-lang">tsx</span>
        </div>
        <pre><span class="k">const</span> <span class="t">Clip</span> = <span class="t">React</span>.memo(({ <span class="v">clip</span>, <span class="v">zoom</span> }) => {
  <span class="c">// Only recalculate position when clip or zoom changes</span>
  <span class="k">const</span> <span class="v">position</span> = useMemo(
    () => ({
      left: clip.start * zoom,
      width: clip.duration * zoom
    }),
    [clip.start, clip.duration, zoom]
  )
  
  <span class="k">return</span> <span class="p">&lt;</span><span class="t">div</span> <span class="v">style</span>={position}<span class="p">&gt;</span>{clip.name}<span class="p">&lt;/</span><span class="t">div</span><span class="p">&gt;</span>
})</pre>
      </div>

      <h4>3. requestAnimationFrame for Dragging</h4>
      <div class="code-block">
        <div class="code-header">
          <span class="code-filename">Throttle updates during drag</span>
          <span class="code-lang">typescript</span>
        </div>
        <pre><span class="k">const</span> <span class="f">handleMouseMove</span> = useCallback((<span class="v">e</span>: <span class="t">MouseEvent</span>) => {
  <span class="c">// Cancel previous frame</span>
  <span class="k">if</span> (rafRef.current) {
    cancelAnimationFrame(rafRef.current)
  }
  
  <span class="c">// Schedule update for next frame</span>
  rafRef.current = requestAnimationFrame(() => {
    setDragState(<span class="v">prev</span> => ({
      ...prev,
      currentX: e.clientX
    }))
  })
}, [])</pre>
      </div>

      <h3>Performance Checklist</h3>
      <div class="checklist">
        <div class="checklist-item">
          <div class="checklist-checkbox"></div>
          <div class="checklist-text">Use React.memo for Clip and Track components</div>
        </div>
        <div class="checklist-item">
          <div class="checklist-checkbox"></div>
          <div class="checklist-text">Virtualize track list for 20+ tracks</div>
        </div>
        <div class="checklist-item">
          <div class="checklist-checkbox"></div>
          <div class="checklist-text">Use CSS transforms instead of left/top for animations</div>
        </div>
        <div class="checklist-item">
          <div class="checklist-checkbox"></div>
          <div class="checklist-text">Debounce expensive operations (auto-save, preview generation)</div>
        </div>
        <div class="checklist-item">
          <div class="checklist-checkbox"></div>
          <div class="checklist-text">Profile with React DevTools before optimizing</div>
        </div>
      </div>
    </div>

    <hr>

    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
    <!-- TESTING -->
    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->

    <div class="section" id="testing">
      <div class="section-tag">Chapter 15</div>
      <h2>Testing Strategy</h2>
      <p class="section-intro">
        Tests are not optional. They let you refactor with confidence and catch bugs before users do.
      </p>

      <h3>Core Package Tests (Vitest)</h3>
      <div class="code-block">
        <div class="code-header">
          <span class="code-filename">packages/core/tests/mutations.test.ts</span>
          <span class="code-lang">typescript</span>
        </div>
        <pre><span class="k">import</span> { describe, it, expect } <span class="k">from</span> <span class="s">'vitest'</span>
<span class="k">import</span> { moveClip, splitClip } <span class="k">from</span> <span class="s">'../src/mutations'</span>
<span class="k">import</span> { <span class="t">Timeline</span> } <span class="k">from</span> <span class="s">'../src/types'</span>

describe(<span class="s">'moveClip'</span>, () => {
  it(<span class="s">'should move clip to new time'</span>, () => {
    <span class="k">const</span> <span class="v">timeline</span>: <span class="t">Timeline</span> = {
      id: <span class="s">'test'</span>,
      tracks: [{
        id: <span class="s">'track-1'</span>,
        clips: [{
          id: <span class="s">'clip-1'</span>,
          start: <span class="n">0</span>,
          duration: <span class="n">5</span>,
          trackId: <span class="s">'track-1'</span>
        }]
      }]
    }
    
    <span class="k">const</span> <span class="v">result</span> = moveClip(timeline, <span class="s">'clip-1'</span>, <span class="n">10</span>)
    
    expect(result.tracks[<span class="n">0</span>].clips[<span class="n">0</span>].start).toBe(<span class="n">10</span>)
  })
  
  it(<span class="s">'should not mutate original timeline'</span>, () => {
    <span class="k">const</span> <span class="v">timeline</span> = createTestTimeline()
    <span class="k">const</span> <span class="v">result</span> = moveClip(timeline, <span class="s">'clip-1'</span>, <span class="n">10</span>)
    
    expect(timeline).not.toBe(result)
    expect(timeline.tracks[<span class="n">0</span>].clips[<span class="n">0</span>].start).toBe(<span class="n">0</span>)
  })
})</pre>
      </div>

      <h3>React Hooks Tests</h3>
      <div class="code-block">
        <div class="code-header">
          <span class="code-filename">packages/react/tests/useTimeline.test.tsx</span>
          <span class="code-lang">typescript</span>
        </div>
        <pre><span class="k">import</span> { renderHook, act } <span class="k">from</span> <span class="s">'@testing-library/react'</span>
<span class="k">import</span> { useTimeline } <span class="k">from</span> <span class="s">'../src/hooks/useTimeline'</span>

describe(<span class="s">'useTimeline'</span>, () => {
  it(<span class="s">'should move clip when action called'</span>, () => {
    <span class="k">const</span> <span class="v">timeline</span> = createTestTimeline()
    <span class="k">const</span> { result } = renderHook(() => useTimeline(timeline))
    
    act(() => {
      result.current.actions.moveClip(<span class="s">'clip-1'</span>, <span class="n">10</span>)
    })
    
    expect(
      result.current.timeline.tracks[<span class="n">0</span>].clips[<span class="n">0</span>].start
    ).toBe(<span class="n">10</span>)
  })
})</pre>
      </div>

      <h3>Test Coverage Goals</h3>
      <ul>
        <li><strong>Core package:</strong> 90%+ coverage (it's pure functions, easy to test)</li>
        <li><strong>React hooks:</strong> 80%+ coverage</li>
        <li><strong>Components:</strong> 60%+ coverage (focus on interaction logic)</li>
      </ul>
    </div>

    <hr>

    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
    <!-- DOCUMENTATION -->
    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->

    <div class="section" id="documentation">
      <div class="section-tag">Chapter 16</div>
      <h2>Documentation Site</h2>
      <p class="section-intro">
        Great docs are what turn a library into a successful product. Invest heavily here.
      </p>

      <h3>Documentation Structure</h3>
      <div class="code-block">
        <div class="code-header">
          <span class="code-filename">apps/docs/ structure</span>
          <span class="code-lang">plaintext</span>
        </div>
        <pre>docs/
‚îú‚îÄ‚îÄ getting-started/
‚îÇ   ‚îú‚îÄ‚îÄ installation.mdx
‚îÇ   ‚îú‚îÄ‚îÄ quickstart.mdx
‚îÇ   ‚îî‚îÄ‚îÄ concepts.mdx
‚îú‚îÄ‚îÄ api-reference/
‚îÇ   ‚îú‚îÄ‚îÄ core/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mutations.mdx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ queries.mdx
‚îÇ   ‚îî‚îÄ‚îÄ react/
‚îÇ       ‚îú‚îÄ‚îÄ useTimeline.mdx
‚îÇ       ‚îî‚îÄ‚îÄ usePlayback.mdx
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ timeline.mdx
‚îÇ   ‚îú‚îÄ‚îÄ track.mdx
‚îÇ   ‚îî‚îÄ‚îÄ clip.mdx
‚îú‚îÄ‚îÄ examples/
‚îÇ   ‚îú‚îÄ‚îÄ basic-timeline.mdx
‚îÇ   ‚îú‚îÄ‚îÄ video-editor.mdx
‚îÇ   ‚îî‚îÄ‚îÄ audio-editor.mdx
‚îî‚îÄ‚îÄ guides/
    ‚îú‚îÄ‚îÄ customization.mdx
    ‚îú‚îÄ‚îÄ performance.mdx
    ‚îî‚îÄ‚îÄ migration.mdx</pre>
      </div>

      <h3>Interactive Examples</h3>
      <p>Use code sandboxes or live preview:</p>

      <div class="code-block">
        <div class="code-header">
          <span class="code-filename">Example with live preview</span>
          <span class="code-lang">mdx</span>
        </div>
        <pre><span class="c"># Basic Timeline Example</span>

Here's a minimal timeline with drag-and-drop:

```tsx
<span class="k">import</span> { Timeline } <span class="k">from</span> <span class="s">'@/components/timeline'</span>
<span class="k">import</span> { TimelineProvider } <span class="k">from</span> <span class="s">'@timeline/react'</span>

<span class="k">export function</span> <span class="f">App</span>() {
  <span class="k">const</span> <span class="v">timeline</span> = { <span class="c">/* ... */</span> }
  
  <span class="k">return</span> (
    <span class="p">&lt;</span><span class="t">TimelineProvider</span> <span class="v">initialTimeline</span>={timeline}<span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="t">Timeline</span> <span class="p">/&gt;</span>
    <span class="p">&lt;/</span><span class="t">TimelineProvider</span><span class="p">&gt;</span>
  )
}
```

<span class="p">&lt;</span><span class="t">Preview</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="t">BasicTimelineDemo</span> <span class="p">/&gt;</span>
<span class="p">&lt;/</span><span class="t">Preview</span><span class="p">&gt;</span></pre>
      </div>

      <h3>Documentation Essentials</h3>
      <div class="feature-grid">
        <div class="feature-card">
          <span class="feature-icon">üìñ</span>
          <h4>Getting Started</h4>
          <p>5-minute quickstart that gets users to a working timeline</p>
        </div>
        <div class="feature-card">
          <span class="feature-icon">üìö</span>
          <h4>API Reference</h4>
          <p>Every function, hook, and prop documented with examples</p>
        </div>
        <div class="feature-card">
          <span class="feature-icon">üé®</span>
          <h4>Component Gallery</h4>
          <p>Visual showcase of all components with variations</p>
        </div>
        <div class="feature-card">
          <span class="feature-icon">üí°</span>
          <h4>Guides</h4>
          <p>Deep dives: customization, performance, advanced patterns</p>
        </div>
      </div>
    </div>

    <hr>

    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
    <!-- COMMON PITFALLS -->
    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->

    <div class="section" id="pitfalls">
      <div class="section-tag">Chapter 17</div>
      <h2>Common Pitfalls to Avoid</h2>
      <p class="section-intro">
        Learn from mistakes others have made. Here are the traps that will derail your project.
      </p>

      <h3>üö´ Pitfall #1: Mixing Layers</h3>
      <div class="callout callout-danger">
        <div class="callout-title">‚ùå WRONG: React in Core</div>
        <div class="code-block" style="margin: 12px 0;">
          <pre><span class="c">// packages/core/src/mutations.ts</span>
<span class="k">import</span> { useState } <span class="k">from</span> <span class="s">'react'</span> <span class="c">// ‚ùå NO!</span></pre>
        </div>
        <p><strong>Why bad:</strong> Core package becomes React-only. Can't support Vue/Svelte.</p>
        <p><strong>Fix:</strong> Keep core 100% framework-agnostic. No React, no DOM, no side effects.</p>
      </div>

      <h3>üö´ Pitfall #2: Mutating State</h3>
      <div class="callout callout-danger">
        <div class="callout-title">‚ùå WRONG: Direct Mutation</div>
        <div class="code-block" style="margin: 12px 0;">
          <pre><span class="k">function</span> <span class="f">moveClip</span>(<span class="v">timeline</span>, <span class="v">clipId</span>, <span class="v">newStart</span>) {
  <span class="k">const</span> <span class="v">clip</span> = timeline.tracks[<span class="n">0</span>].clips[<span class="n">0</span>]
  clip.start = newStart <span class="c">// ‚ùå Mutation!</span>
  <span class="k">return</span> timeline
}</pre>
        </div>
        <p><strong>Why bad:</strong> Breaks React's change detection. Undo/redo impossible. Hard to debug.</p>
        <p><strong>Fix:</strong> Always return NEW objects. Use spread operators {...obj}.</p>
      </div>

      <h3>üö´ Pitfall #3: Premature Optimization</h3>
      <div class="callout callout-warning">
        <div class="callout-title">‚ö†Ô∏è Don't Optimize Too Early</div>
        <p>Building custom virtualization before you have 100 clips? Writing a WebWorker for calculations that take 2ms? <strong>Stop.</strong></p>
        <p><strong>Fix:</strong> Build it working first. Profile with Chrome DevTools. Optimize what's actually slow.</p>
      </div>

      <h3>üö´ Pitfall #4: Over-Engineering</h3>
      <div class="callout callout-warning">
        <div class="callout-title">‚ö†Ô∏è Don't Build Everything Upfront</div>
        <p>Adding plugin systems, extension APIs, and event buses before you have basic drag-and-drop working?</p>
        <p><strong>Fix:</strong> Ship core features first. Add extensibility when users ask for it.</p>
      </div>

      <h3>üö´ Pitfall #5: Poor CLI UX</h3>
      <div class="callout callout-danger">
        <div class="callout-title">‚ùå Bad CLI Experience</div>
        <ul>
          <li>No progress indicators during install</li>
          <li>Cryptic error messages</li>
          <li>Doesn't detect framework automatically</li>
          <li>Overwrites user files without asking</li>
        </ul>
        <p><strong>Fix:</strong> Add spinners (ora), helpful errors, confirmation prompts, auto-detection.</p>
      </div>

      <h3>üö´ Pitfall #6: Skipping Tests</h3>
      <div class="callout callout-danger">
        <div class="callout-title">‚ùå "I'll Add Tests Later"</div>
        <p>No you won't. And then you'll break core functions while adding features.</p>
        <p><strong>Fix:</strong> Write tests WHILE building. At minimum, test all core package functions.</p>
      </div>

      <h3>üö´ Pitfall #7: Video Editor First</h3>
      <div class="callout callout-danger">
        <div class="callout-title">‚ùå Building Video Playback First</div>
        <p>Starting with video playback, encoding, effects before the timeline works?</p>
        <p><strong>Fix:</strong> Build timeline library first. Make it excellent. Video features = Phase 2.</p>
      </div>

      <h3>‚úÖ Success Patterns</h3>
      <div class="feature-grid">
        <div class="feature-card">
          <span class="feature-icon">üéØ</span>
          <h4>Start Small</h4>
          <p>Ship timeline library v1.0 with just core features. Iterate based on feedback.</p>
        </div>
        <div class="feature-card">
          <span class="feature-icon">üìê</span>
          <h4>Respect Layers</h4>
          <p>Core = pure. Adapters = thin. Components = user-owned. Never mix.</p>
        </div>
        <div class="feature-card">
          <span class="feature-icon">üß™</span>
          <h4>Test Everything</h4>
          <p>Core package must have 80%+ coverage. Sleep well at night.</p>
        </div>
        <div class="feature-card">
          <span class="feature-icon">üìö</span>
          <h4>Document Well</h4>
          <p>Docs = product. Invest in examples, guides, videos.</p>
        </div>
      </div>
    </div>

    <hr>

    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
    <!-- ROADMAP -->
    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->

    <div class="section" id="roadmap">
      <div class="section-tag">Chapter 18</div>
      <h2>Development Roadmap</h2>
      <p class="section-intro">
        Here's the complete 14-week plan to ship v1.0. Follow this order ‚Äî resist the urge to jump ahead.
      </p>

      <div class="phase">
        <div class="phase-header">
          <div class="phase-title">Week 1-2: Foundation</div>
          <div class="phase-timeline">Critical Path</div>
        </div>
        <div class="phase-desc">Set up infrastructure that won't change.</div>
        <ul class="phase-tasks">
          <li>Initialize monorepo: `npx create-turbo@latest timeline-library`</li>
          <li>Set up packages: core, react, cli, docs</li>
          <li>Configure TypeScript (strict mode), ESLint, Prettier</li>
          <li>Write ALL type definitions in packages/core/src/types.ts</li>
          <li>Set up Vitest for testing</li>
          <li>Create GitHub repo with CI/CD (GitHub Actions)</li>
          <li>Write README with vision and goals</li>
        </ul>
      </div>

      <div class="phase">
        <div class="phase-header">
          <div class="phase-title">Week 3-5: Core Logic</div>
          <div class="phase-timeline">Foundation</div>
        </div>
        <div class="phase-desc">Build pure functions with comprehensive tests.</div>
        <ul class="phase-tasks">
          <li>Implement mutations.ts: moveClip, trimClip, splitClip, deleteClip</li>
          <li>Implement mutations.ts: addTrack, deleteTrack, reorderTracks</li>
          <li>Implement queries.ts: getActiveClipsAtTime, getNextEditPoint</li>
          <li>Implement utils.ts: timeToPixels, pixelsToTime, snapToGrid</li>
          <li>Write unit tests for EVERY function (aim for 90%+ coverage)</li>
          <li>Add JSDoc comments to all public APIs</li>
          <li>Build first version: `turbo build`</li>
        </ul>
      </div>

      <div class="phase">
        <div class="phase-header">
          <div class="phase-title">Week 6-7: React Adapter</div>
          <div class="phase-timeline">Framework Integration</div>
        </div>
        <div class="phase-desc">Connect core to React with hooks.</div>
        <ul class="phase-tasks">
          <li>Create useTimeline() hook</li>
          <li>Create useHistory() hook (undo/redo)</li>
          <li>Create usePlayback() hook</li>
          <li>Create useDrag() hook</li>
          <li>Create useZoom() hook</li>
          <li>Create TimelineContext provider</li>
          <li>Build demo app in apps/playground to test hooks</li>
          <li>Write tests for all hooks</li>
        </ul>
      </div>

      <div class="phase">
        <div class="phase-header">
          <div class="phase-title">Week 8-10: UI Components</div>
          <div class="phase-timeline">User-Facing Code</div>
        </div>
        <div class="phase-desc">Build components that go in registry/</div>
        <ul class="phase-tasks">
          <li>Create Timeline component (root container)</li>
          <li>Create Track component</li>
          <li>Create Clip component (draggable, resizable)</li>
          <li>Create Playhead component</li>
          <li>Create TimeRuler component</li>
          <li>Create TrackControls component</li>
          <li>Add basic styling (Tailwind or plain CSS)</li>
          <li>Create registry.json metadata</li>
          <li>Test all components in playground app</li>
        </ul>
      </div>

      <div class="phase">
        <div class="phase-header">
          <div class="phase-title">Week 11: CLI Tool</div>
          <div class="phase-timeline">Magic Installer</div>
        </div>
        <div class="phase-desc">Build the CLI that makes installation feel like magic.</div>
        <ul class="phase-tasks">
          <li>Set up packages/cli with Commander.js</li>
          <li>Implement `timeline init` command</li>
          <li>Implement `timeline add [component]` command</li>
          <li>Add framework detection (React/Vue/Svelte)</li>
          <li>Handle dependency resolution</li>
          <li>Add progress spinners and nice output</li>
          <li>Test CLI in fresh React/Next.js project</li>
          <li>Publish CLI to npm as `timeline-cli`</li>
        </ul>
      </div>

      <div class="phase">
        <div class="phase-header">
          <div class="phase-title">Week 12-14: Documentation</div>
          <div class="phase-timeline">Critical for Adoption</div>
        </div>
        <div class="phase-desc">Build docs site and write comprehensive guides.</div>
        <ul class="phase-tasks">
          <li>Set up docs site (Next.js + MDX or Astro)</li>
          <li>Write Getting Started guide (installation, quickstart)</li>
          <li>Write API reference for all core functions</li>
          <li>Write API reference for all React hooks</li>
          <li>Create component documentation with live examples</li>
          <li>Write customization guide</li>
          <li>Write performance guide</li>
          <li>Add search functionality</li>
          <li>Deploy docs to Vercel/Netlify</li>
          <li>Record 3-5 minute demo video</li>
        </ul>
      </div>

      <div class="callout callout-success">
        <div class="callout-title">‚úÖ v1.0 Checklist</div>
        <p>You're ready to ship when you have:</p>
        <ul>
          <li>‚úÖ Core package with 20+ functions, 90%+ test coverage</li>
          <li>‚úÖ React adapter with 5+ hooks</li>
          <li>‚úÖ 6+ UI components in registry</li>
          <li>‚úÖ Working CLI that installs in 30 seconds</li>
          <li>‚úÖ Documentation site with examples and API docs</li>
          <li>‚úÖ Demo video showing key features</li>
          <li>‚úÖ Published to npm: @timeline/core, @timeline/react, timeline-cli</li>
        </ul>
      </div>
    </div>

    <hr>

    <div class="section" id="next-steps">
      <div class="section-tag">Final Chapter</div>
      <h2>Your Next Steps</h2>
      <p class="section-intro">
        You now have the complete blueprint. Here's exactly what to build, in what order, and how to avoid getting stuck.
      </p>

      <h3>Development Phases</h3>

      <div class="phase">
        <div class="phase-header">
          <div class="phase-title">Phase 1: Foundation (Week 1-2)</div>
          <div class="phase-timeline">Critical</div>
        </div>
        <div class="phase-desc">Set up infrastructure that won't need to change.</div>
        <ul class="phase-tasks">
          <li>Initialize monorepo with Turborepo or pnpm workspaces</li>
          <li>Create package structure: core, react, vue, cli, docs</li>
          <li>Set up TypeScript configs with strict mode</li>
          <li>Configure ESLint, Prettier, Vitest</li>
          <li>Write all type definitions in packages/core/src/types.ts</li>
          <li>Set up GitHub repo with CI/CD (GitHub Actions)</li>
        </ul>
      </div>

      <div class="phase">
        <div class="phase-header">
          <div class="phase-title">Phase 2: Core Logic (Week 3-5)</div>
          <div class="phase-timeline">Essential</div>
        </div>
        <div class="phase-desc">Build the pure functions that power everything.</div>
        <ul class="phase-tasks">
          <li>Implement clip manipulation: moveClip, trimClip, splitClip, deleteClip</li>
          <li>Implement track management: addTrack, deleteTrack, reorderTracks</li>
          <li>Implement query functions: getActiveClipsAtTime, getNextEditPoint</li>
          <li>Implement time utilities: timeToPixels, pixelsToTime, snapToGrid</li>
          <li>Write comprehensive unit tests for all functions (80%+ coverage)</li>
          <li>Document all public APIs with JSDoc</li>
        </ul>
      </div>

      <div class="phase">
        <div class="phase-header">
          <div class="phase-title">Phase 3: React Adapter (Week 6-7)</div>
          <div class="phase-timeline">Important</div>
        </div>
        <div class="phase-desc">Connect core logic to React with hooks.</div>
        <ul class="phase-tasks">
          <li>Create useTimeline() hook for state management</li>
          <li>Create useHistory() hook for undo/redo</li>
          <li>Create useDrag() hook for drag interactions</li>
          <li>Create usePlayback() hook for play/pause/scrub</li>
          <li>Create useZoom() hook for zoom/pan controls</li>
          <li>Build demo app to test all hooks</li>
        </ul>
      </div>

      <div class="phase">
        <div class="phase-header">
          <div class="phase-title">Phase 4: UI Components (Week 8-10)</div>
          <div class="phase-timeline">Critical</div>
        </div>
        <div class="phase-desc">Build the actual timeline UI that users install.</div>
        <ul class="phase-tasks">
          <li>Create Timeline component (root container)</li>
          <li>Create TimelineTrack component</li>
          <li>Create TimelineClip component with drag/resize</li>
          <li>Create Playhead component with scrubbing</li>
          <li>Create TimeRuler component with time markers</li>
          <li>Create TrackControls component (mute, solo, lock)</li>
          <li>Add all components to registry/ for CLI</li>
        </ul>
      </div>

      <div class="phase">
        <div class="phase-header">
          <div class="phase-title">Phase 5: CLI Tool (Week 11)</div>
          <div class="phase-timeline">Essential</div>
        </div>
        <div class="phase-desc">Build the magic installation experience.</div>
        <ul class="phase-tasks">
          <li>Set up packages/cli with Commander.js</li>
          <li>Implement 'timeline init' command</li>
          <li>Implement 'timeline add [component]' command</li>
          <li>Handle framework detection (React, Vue, etc.)</li>
          <li>Handle dependency installation automatically</li>
          <li>Test CLI in fresh projects</li>
        </ul>
      </div>

      <div class="phase">
        <div class="phase-header">
          <div class="phase-title">Phase 6: Documentation (Week 12-14)</div>
          <div class="phase-timeline">Important</div>
        </div>
        <div class="phase-desc">Make your library discoverable and usable.</div>
        <ul class="phase-tasks">
          <li>Build docs site with Next.js or Astro</li>
          <li>Write getting started guide</li>
          <li>Document all core functions with examples</li>
          <li>Create interactive component playground</li>
          <li>Record video tutorials</li>
          <li>Write migration guides for popular editors</li>
        </ul>
      </div>

      <div class="callout callout-danger">
        <div class="callout-title">‚ö†Ô∏è Common Mistakes to Avoid</div>
        <ul>
          <li><strong>Don't build everything at once</strong> ‚Äî Start with Phase 1-3, ship that, then iterate</li>
          <li><strong>Don't optimize prematurely</strong> ‚Äî Build it working first, then profile and optimize</li>
          <li><strong>Don't skip tests</strong> ‚Äî Core functions MUST have tests or you'll break things constantly</li>
          <li><strong>Don't couple layers</strong> ‚Äî Keep core, adapters, and UI completely separate</li>
          <li><strong>Don't build the video editor yet</strong> ‚Äî Timeline library first, video features later</li>
        </ul>
      </div>

      <h3>Success Criteria</h3>
      <p>You're ready to ship v1.0 when you have:</p>
      <div class="checklist">
        <div class="checklist-item">
          <div class="checklist-checkbox"></div>
          <div class="checklist-text">Core package with full type definitions and 80%+ test coverage</div>
        </div>
        <div class="checklist-item">
          <div class="checklist-checkbox"></div>
          <div class="checklist-text">React adapter with useTimeline, useHistory, useDrag hooks</div>
        </div>
        <div class="checklist-item">
          <div class="checklist-checkbox"></div>
          <div class="checklist-text">5+ working UI components (Timeline, Track, Clip, Playhead, Ruler)</div>
        </div>
        <div class="checklist-item">
          <div class="checklist-checkbox"></div>
          <div class="checklist-text">CLI that installs components in 30 seconds</div>
        </div>
        <div class="checklist-item">
          <div class="checklist-checkbox"></div>
          <div class="checklist-text">Documentation site with examples and API reference</div>
        </div>
        <div class="checklist-item">
          <div class="checklist-checkbox"></div>
          <div class="checklist-text">Working demo app showcasing all features</div>
        </div>
      </div>

      <div class="callout callout-success" style="margin-top: 48px;">
        <div class="callout-title">üöÄ You're Ready to Build</div>
        <p>You have everything you need:</p>
        <ul>
          <li>Clear architecture (3-layer separation)</li>
          <li>Data model (immutable timeline schema)</li>
          <li>State management strategy (pure functions + history)</li>
          <li>Technology choices (TypeScript, React, Turborepo)</li>
          <li>Execution plan (14-week roadmap)</li>
        </ul>
        <p style="margin-top: 16px;"><strong>Start with Phase 1.</strong> Get the types right. Build the core layer with tests. Everything else will flow naturally from there.</p>
        <p style="margin-top: 12px;">You're not building a video editor ‚Äî you're building the <strong>foundation</strong> that enables a thousand video editors to be built. That's the real vision. Now go make it real.</p>
      </div>
    </div>

  </main>
</div>

<script>
// Active nav highlighting on scroll
const sections = document.querySelectorAll('.section[id]');
const navItems = document.querySelectorAll('.nav-item');

const observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      navItems.forEach(item => item.classList.remove('active'));
      const active = document.querySelector(`.nav-item[href="#${entry.target.id}"]`);
      if (active) active.classList.add('active');
    }
  });
}, { 
  threshold: 0.3, 
  rootMargin: '-100px 0px -60% 0px' 
});

sections.forEach(s => observer.observe(s));
</script>

</body>
</html>